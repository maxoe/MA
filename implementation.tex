% !TeX root = thesis.tex
%% implementation.tex
%%

%% ==============
\chapter{Improvements and Implementation\label{ch:impl}}
In this chapter, we describe detailed modifications to the algorithm described in Section \ref{sec:astar_corech} which enable further improvements of running time in specific cases and in practice.

\subparagraph{Label Queue}
In Section \ref{sec:dijkstra_csp}, we introduced our basic approach as an algorithm which maintains one queue $Q$ of labels in contrast to Dijkstra's algorithm, which maintains one queue of nodes. In practice, we revert this change and $Q$ becomes a queue of nodes again. The key of a node $v$ in $Q$ is the best known travel time of a label in $L(v)$. The label set $L(v)$ now becomes a priority queue of labels itself. When settling a label, we remove a node $v$ from $Q$ and the best label $l$ at $v$ from $L(v)$. If $L(v)$ is not empty now, we insert the node $v$ into $Q$ again with the travel time of the new best label $l' \in L(v)$ as the key.

\subparagraph{Bidirectional Backward Pruning}
With a bidirectional A* search, we can use the progress and the potential of the backward search to prune the forward search and vice versa. [TODO cite] A label $l$ at a node $v$ which was propagated along an edge $(u,v)$ can be discarded if we can proof that all paths using the label are longer or equal to the tentative travel time $\tenttraveltime(s,t)$. We know the travel time $\concretett(l)$ of the label $l$ at $v$ and need to find a lower bound for the remaining distance to $t$. We will describe the pruning of the forward search, the backward search can be pruned accordingly.

The backwards queue $\overleftarrow{Q}$ contains labels $l$ with a key of $\concretett(l) + \concretepotential_s(l,v)$ which belong to a label set $\overleftarrow{L}(v)$. Labels are removed from the queue with an increasing key. If $l$ was not yet removed from the backwards queue, we know that $\concretett(l) + \concretepotential_s(l,v) \ge \minKey(\overleftarrow{Q})$ and therefore $\concretett(l) \ge \minKey(\overleftarrow{Q}) - \concretepotential_s(l,v)$. TODO finish

\subparagraph{Core Contraction Hierarchy Stopping Criteria}
Only a subset of nodes of a core CH can be reachable from a core node. This includes all the core nodes and the last layer of contracted nodes of the CH, i.e. all nodes which are contracted themselves but are reachable through an outgoing edge of a core node. If the forward search stops without touching any of the nodes which are reachable from the core, the forward search can only connect with the backwards search within the fully constructed CH part of the core CH. If the backwards search has no contracted nodes left in its queue we can be sure, that forward and backward search will not connect anymore and that no path will be found. Therefore, we can terminate the search. Equivalently, we can terminate the search if the backward search terminates early without touching any nodes which are reachable from the core and the forward search has no uncontracted nodes left in its queue.

\subparagraph{Constructing the Core Contraction Hierarchy}
In chapter \ref{sec:astar_corech} we introduced a core contraction hierarchy algorithm with a core of uncontracted nodes $C$ which contains all the parking nodes $P$. It remains to determine if $C=P$ is the optimal choice for C or if it is beneficial to include more nodes in the core. In general, the parking nodes are not the most important nodes in the graph according to the node order of the CH. Because we declare them as core nodes and contract everything but those nodes, we act as if they were the set of most important nodes which breaks the node order and leads to a CH of lower quality. The idea is to include the most important nodes according to the node order in the core to obtain a CH of higher quality, i.e. with lower node degrees. An additional advantage are shorter build times for the core CH. TODO finish