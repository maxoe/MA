%% content.tex
%%

%% ==============
\chapter{Algorithm}
\label{ch:Algorithm}
%% ==============
In this chapter, we introduce a labeling algorithm which solves the long-haul truck driver routing problem. At first, we will restrict the problem to one driving time constraint for simplicity and drop that constraint later. We then describe extensions of the base algorithm to achieve better runtimes on road networks.

\section{Dijkstra's Algorithm with One Driving Time Constraint\label{sec:dijkstra_csp}}
Dijkstra's algorithm solves the shortest path problem by maintaining a queue $Q$ of nodes with ascending tentative distance from the starting node $s$, and iteratively settling the node with the smallest distance. When Dijkstra settles a node $u$, it tests if the distance to the neighbor nodes $v$ with $(u,v) \in E$ can be improved by choosing the current node as a predecessor. We say it \emph{relaxes} all edges $(u,v) \in E$. The search can be stopped if the target node $t$ was removed from the queue \cite{dijkstra:1959}.

We will adapt Dijkstra's algorithm for solving the long-haul truck driver routing problem with one driving time constraint $\restrset = \{\restr\}$ and abbreviate this restriction of the problem \emph{1-DTC}. While Dijkstra's algorithm manages a queue of nodes and assigns each node one tentative distance, our algorithm manages a queue $Q$ of labels and a set $L(v)$ of labels for each node $v \in V$.

Labels represent a possible route, respectively a possible solution for a query from $s$ to the node they belong to. A label in a label set $L(v)$ may represent suboptimal routes to $v$, i.e., routes which are not a shortest route between $s$ and $v$. A label set never contains labels which represent routes with an invalid path according to $\restr$. A label $l$ contains

\begin{itemize}
	\item $\concretett(l)$, the total travel time from the starting node $s$
	\item $\breakDist(l)$, the driving time since the last break
	\item $\pred(l)$, its preceding label
\end{itemize}

\subsection{Settling a Label}
In contrast to Dijkstra, the search \emph{settles} a label $l \in L(u)$ in each iteration instead of a node $u$. When settling a label, the search first removes $l$ from the queue. Similar to Dijkstra, it then relaxes all edges $(u,v) \in E$ with $l \in L(u)$ as shown in fig. \ref{alg:settle_next_label}.

\begin{figure}[hbtp]
	\setlength{\interspacetitleruled}{0pt}%
	\setlength{\algotitleheightrule}{0pt}%
	\begin{algorithm*}[H]
		\SetFuncSty{textsc}
		\DontPrintSemicolon
		\SetKwData{Q}{Q}
		\SetKwData{L}{L}

		\SetKwFunction{settleNextLabel}{settleNextLabel}
		\SetKwFunction{relaxEdge}{relaxEdge}
		\SetKwFunction{queueDeleteMin}{deleteMin}

		\SetKwProg{Pn}{Procedure}{:}{\KwRet}
		\Pn{\settleNextLabel{}}{
			$l \leftarrow$ \Q.\queueDeleteMin{} \;
			\BlankLine

			\ForAll{ $(u,v) \in E$ }
			{
				\relaxEdge{$(u,v),l$}
			}
		}
	\end{algorithm*}
	\setlength{\interspacetitleruled}{2pt}%
	\setlength{\algotitleheightrule}{\algotitleheightruledefault}%

	\caption{\label{alg:settle_next_label}Settling a label $l \in L(u)$ removes the label from the queue and relaxes all the outgoing edges of $u$.}
\end{figure}

Relaxing an edge consists of the three steps label \emph{propagation}, \emph{pruning} and \emph{dominance} checks.

\paragraph{Label Propagation.}
Labels can be propagated along edges. Let $l \in L(u)$ be a label at $u$ and $(u,v) = e \in E$, then $l$ can be propagated to $v$ resulting in a label $l'$ with $\concretett(l') = \concretett(l) + \mathfunction{len}(e)$, $\breakDist(l') = \breakDist(l) + \mathfunction{len}(e)$, and $\pred(l') = l$.

\paragraph{Label Pruning.}
After propagating a label, we discard the label if it violates the driving time constraint $\restr$. That is, if $\breakDist(l) > \restr_d$.


\paragraph{Label Dominance}
In general, it is no longer clear when a label presents a better solution than another label since it now contains two distance values. A label $l$ at a node $v$ might represent a shorter route from $s$ to $v$ than another label $m$ but might have shorter remaining driving time budget $\restr_d - \breakDist(l)$. The label $l$ yields a better solution for a query $s$-$v$, but this does not imply that it is part of a better solution for a query from $s$-$t$. It might not even yield a valid path to $t$ at all while $m$ reaches the target due to the greater remaining driving time budget. In one case we can proof that a label $l \in L(v)$ cannot yield a better solution than a label $m \in L(v)$. We say $m$ \emph{dominates} $l$.

\begin{definition}[Label Dominance for 1-DTC]
	A label $l \in L(v)$ dominates another label $l' \in L(v)$ if $\concretett(l') \ge \concretett(l)$ and $\breakDist(l') \ge \breakDist(l)$.
\end{definition}

If a label $l \in L(v)$ is dominated by another label $m \in L(v)$, then $m$ represents a route from $s$ to $t$ with a shorter or equal total travel time and longer or equal remaining driving time budget until the next break. Therefore, in each solution which uses the label $l$, $l$ can trivially be replaced by the label $m$. The solution will still comply with the driving time constraint $\restr$ and yield a shorter or equal total travel time, so we are allowed to simply discard dominated labels in our search.

\begin{definition}[Pareto-Optimal Label]
	A label $l \in L(v)$ is pareto-optimal if it is not dominated by any other label $m \in L(v)$.
\end{definition}

A label $l$ will only be inserted into a label set $L(v)$ if it is pareto-optimal. If a label $l$ is inserted into $L(v)$, labels $m \in L(v)$ are removed from $L(v)$ if $l$ dominates them. $L(v)$ therefore is the set of known pareto-optimal solutions at $v$. In fig. \ref{alg:remove_dominated} we define the procedure \textsc{removeDominated($l$)} as an operation on a label set.

\begin{figure}[hbtp]
	\setlength{\interspacetitleruled}{0pt}%
	\setlength{\algotitleheightrule}{0pt}%
	\begin{algorithm*}[H]
		\SetFuncSty{textsc}
		\SetKwFor{ForAll}{forall}{do}
		\DontPrintSemicolon
		\SetKwData{L}{L}

		\SetKwFunction{removeDominated}{removeDominated}
		\SetKwFunction{queueRemove}{remove}

		\SetKwProg{Pn}{Procedure}{:}{\KwRet}
		\Pn{\removeDominated{$l$}}{
			\ForAll{$m \in L$}
			{
				\If{\text{$l$ dominates $m$}}{
					\L.\queueRemove($m$)\;
				}
			}
		}
	\end{algorithm*}
	\setlength{\interspacetitleruled}{2pt}%
	\setlength{\algotitleheightrule}{\algotitleheightruledefault}%

	\caption{\label{alg:remove_dominated}The procedure $L$.\textsc{removeDominated}($l$) removes all labels from the label set $L$ which are dominated by the label $l$.}
\end{figure}

We now use \textsc{removeDominated} to define the procedure \textsc{relaxEdge$'$} as described in fig. \ref{alg:relax_edge_no_p} which propagates a label along an edge and updates the neighbor node's label set if necessary.

\begin{figure}[hbtp]
	\setlength{\interspacetitleruled}{0pt}%
	\setlength{\algotitleheightrule}{0pt}%
	\begin{algorithm*}[H]
		\SetFuncSty{textsc}
		\DontPrintSemicolon
		\SetKwData{Q}{Q}
		\SetKwData{L}{L}

		\SetKwFunction{relaxEdgeNoP}{relaxEdge$'$}
		\SetKwFunction{queueDeleteMin}{deleteMin}

		\SetKwData{Q}{Q}
		\SetKwData{dist}{d}
		\SetKwData{L}{L}
		\SetKwData{pred}{pred}
		\SetKwArray{ds}{ds}
		\SetKwFunction{queueDeleteMin}{deleteMin}
		\SetKwFunction{queueInsert}{queueInsert}
		\SetKwFunction{setInsert}{insert}
		\SetKwFunction{queueMin}{min}
		\SetKwFunction{queueMinKey}{minKey}
		\SetKwFunction{queueDecreaseKey}{decreaseKey}
		\SetKwFunction{queueContains}{contains}
		\SetKwFunction{listInsert}{insert}
		\SetKwFunction{removeDom}{removeDominated}

		\SetKwProg{Pn}{Procedure}{:}{\KwRet}
		\Pn{\relaxEdgeNoP{(u,v), l}}{
			\If{$\breakDist(l) + \mathfunction{len}(u,v) \le \restr_d$}
			{
				$l' \leftarrow \{(\concretett(l) + \mathfunction{len}(u,v), \breakDist(l) + \mathfunction{len}(u,v)), l\}$\;
				\If{$l'$ is not dominated by any label in \L{$v$}}
				{
					\L{$v$}.\removeDom{$l'$} \;
					\L{$v$}.\setInsert{$l'$} \;
					\Q.\queueInsert{$\concretett(l')$, $l'$}
				}
			}
		}
	\end{algorithm*}
	\setlength{\interspacetitleruled}{2pt}%
	\setlength{\algotitleheightrule}{\algotitleheightruledefault}%

	\caption{\label{alg:relax_edge_no_p}Relaxing an edge $(u,v) \in E$ when settling a label $l \in L(u)$.}
\end{figure}

\subsection{Parking at a Node}
The procedure \textsc{relaxEdge$'$} does not account for parking nodes. When propagating a label $l \in L(u)$ along an edge $(u,v) \in E$ and $v \in P$, we have to consider pausing at $v$. Since we do not know if pausing at $v$ or continuing without a break is the better solution, we generate both labels and add them to label set $L(v)$ and the queue $Q$ as defined in fig. \ref{alg:relax_edge}.

\begin{figure}[hbtp]
	\setlength{\interspacetitleruled}{0pt}%
	\setlength{\algotitleheightrule}{0pt}%
	\begin{algorithm*}[H]
		\SetFuncSty{textsc}
		\DontPrintSemicolon
		\SetKwData{Q}{Q}
		\SetKwData{L}{L}

		\SetKwFunction{relaxEdge}{relaxEdge}
		\SetKwFunction{queueDeleteMin}{deleteMin}

		\SetKwData{Q}{Q}
		\SetKwData{L}{L}
		\SetKwData{D}{D}
		\SetKwData{pred}{pred}
		\SetKwArray{ds}{ds}
		\SetKwFunction{queueDeleteMin}{deleteMin}
		\SetKwFunction{queueInsert}{queueInsert}
		\SetKwFunction{setInsert}{insert}
		\SetKwFunction{queueMin}{min}
		\SetKwFunction{queueMinKey}{minKey}
		\SetKwFunction{queueDecreaseKey}{decreaseKey}
		\SetKwFunction{queueContains}{contains}
		\SetKwFunction{listInsert}{insert}
		\SetKwFunction{removeDom}{removeDominated}

		\SetKwProg{Pn}{Procedure}{:}{\KwRet}
		\Pn{\relaxEdge{(u,v), l}}{
			$\D \leftarrow \{\}$\;
			\If{$\breakDist(l) + \mathfunction{len}(u,v) \le \restr_d$}
			{
				\D.\setInsert{$(\concretett(l) + \mathfunction{len}(u,v), \breakDist(l) + \mathfunction{len}(u,v), l)$}\;

				\If{$v \in P$}
				{
					\D.\setInsert{$(\concretett(l) + \mathfunction{len}(u,v) + \restr_b, 0, l)$}\;
				}

				\ForAll{ $l' \in D$ }
				{
					\If{$l'$ is not dominated by any label in \L{$v$}}
					{
						\L{$v$}.\removeDom{$l'$} \;
						\L{$v$}.\setInsert{$l'$} \;
						\Q.\queueInsert{$\concretett(l')$,$l'$}
					}
				}
			}
		}
	\end{algorithm*}
	\setlength{\interspacetitleruled}{2pt}%
	\setlength{\algotitleheightrule}{\algotitleheightruledefault}%

	\caption{\label{alg:relax_edge}Relaxing an edge $(u,v) \in E$ when settling a label $l \in L(u)$ with regard to parking nodes.}
\end{figure}

\subsection{Initialization and Stopping Criterion}
We initialize the label set $L(s)$ of $s$ and the queue $Q$ with a label which only contains distances of zero and a dummy element as a predecessor. We stop the search when $t$ was removed from $Q$. The definition of the final algorithm \ref{alg:CSP} \textsc{Dijkstra+1-DTC} is now trivial.

\begin{algorithm}[bt]
	\caption{\textsc{Dijkstra+1-DTC}}\label{alg:CSP}

	% Some settings
	\DontPrintSemicolon %dontprintsemicolon
	\SetFuncSty{textsc}
	\SetKwFor{ForAll}{forall}{do}

	% Declaration of data containers and functions
	\SetKwData{Q}{Q}
	\SetKwData{dist}{d}
	\SetKwData{L}{L}
	\SetKwData{pred}{pred}
	\SetKwArray{ds}{ds}
	\SetKwFunction{queueDeleteMin}{deleteMin}
	\SetKwFunction{queueInsert}{queueInsert}
	\SetKwFunction{setInsert}{insert}
	\SetKwFunction{queueMin}{min}
	\SetKwFunction{queueMinKey}{minKey}
	\SetKwFunction{queueDecreaseKey}{decreaseKey}
	\SetKwFunction{queueContains}{contains}
	\SetKwFunction{listInsert}{insert}
	\SetKwFunction{removeDom}{removeDominated}
	\SetKwFunction{settleNextLabel}{settleNextLabel}

	% Algorithm interface
	\KwIn{Graph $G=(V,E,\mathfunction{len})$, set of parking nodes $P \subseteq V$, set of driving time constraints $\restrset=\{r\}$, start and target nodes $s,t \in V$}
	\KwData{Priority queue \Q, per node set \L{$v$} of labels for all $v \in V$}
	\KwOut{Shortest route with $\concretett(j) = \traveltime(s,t)$}

	% The algorithm
	\BlankLine
	\tcp{Initialization}
	\Q.\queueInsert{$0$,$(0,0,\bot)$}\;
	\L{$s$}.\setInsert{$(0,0,\bot)$}\;
	\BlankLine
	\tcp{Main loop}
	\While{\Q is not empty}
	{
		\settleNextLabel{}\;

		\If{\text{label at $t$ was settled}}
		{
			\Return\;
		}
	}
\end{algorithm}

\subsection{Correctness\label{sec:dijkstra_csp_correctness}}
An $s$-$t$ query with the original Dijkstra's algorithm can be stopped when $t$ was removed from the queue since all of the following nodes in the queue have larger distances and edge lengths are non-negative by definition. Therefore, relaxing an outgoing edge of these nodes cannot lead to an improvement of the distance at $t$.
In our case, the labels in the queue are ordered by their travel time. Relaxing an edge can only increase the travel time since both, edge lengths and break times are non-negative. Therefore, the same argument as for the original Dijkstra's algorithm applies and the first label at $t$ which was removed from the queue contains the shortest travel time $\traveltime(s,t)$.

\section{Goal Directed Search with One Driving Time Constraint}
In this section, we transform the base algorithm described in section \ref{sec:dijkstra_csp} to a goal-directed search with the A* algorithm. We introduce a new potential $\concretepotential_t$ which is based on the CH potential $\chpotential_t$ which is described in section \ref{sec:ch_pot}. We then show that we still can stop the search when the first label at $t$ is removed from the queue.

The difference between Dijkstra and A* is the order in which nodes are being removed from the queue. In our case, this corresponds to the order of labels being removed from the queue. Instead of using their travel time $\concretett(l)$ as a queue key, a label $l \in L(v)$ is added to the queue with the key $\concretett(l) + \concretepotential_t(l,v)$. As shown in algorithm \ref{alg:CSPPot}, the adaption of the pseudocode of the coarse algorithm is trivial.

\begin{algorithm}[bt]
	\caption{\textsc{A*+1-DTC}}\label{alg:CSPPot}

	% Some settings
	\DontPrintSemicolon %dontprintsemicolon
	\SetFuncSty{textsc}
	\SetKwFor{ForAll}{forall}{do}

	% Declaration of data containers and functions
	\SetKwData{Q}{Q}
	\SetKwData{dist}{d}
	\SetKwData{L}{L}
	\SetKwData{pred}{pred}
	\SetKwArray{ds}{ds}
	\SetKwFunction{queueDeleteMin}{deleteMin}
	\SetKwFunction{queueInsert}{queueInsert}
	\SetKwFunction{setInsert}{insert}
	\SetKwFunction{queueMin}{min}
	\SetKwFunction{queueMinKey}{minKey}
	\SetKwFunction{queueDecreaseKey}{decreaseKey}
	\SetKwFunction{queueContains}{contains}
	\SetKwFunction{listInsert}{insert}
	\SetKwFunction{removeDom}{removeDominated}
	\SetKwFunction{settleNextNode}{settleNextNode}

	% Algorithm interface
	\KwIn{Graph $G=(V,E,\mathfunction{len})$, set of parking nodes $P \subseteq V$, a set of driving time constraints $\restrset = \{r\}$, start and target nodes $s,t \in V$, potential $\concretepotential_t()$}
	\KwData{Priority queue \Q, per node set \L{$v$} of labels for all $v \in V$}
	\KwOut{Shortest route with $\concretett(j) = \traveltime(s,t)$}

	% The algorithm
	\BlankLine
	\tcp{Initialization}
	$l_s \leftarrow (0,0,\bot)$\;
	\Q.\queueInsert{$\concretepotential_t((l_s),s)$, $l_s$}\;
	\L{$s$}.\setInsert{$l_s$}\;
	\BlankLine
	\tcp{Main loop}
	\While{\Q is not empty}
	{
		\settleNextNode{}\;

		\If{\text{minimum of $Q$ is label at $t$}}
		{
			\Return\;
		}
	}
\end{algorithm}

The only thing left is the adaption of \textsc{relaxEdge} in fig. \ref{alg:relax_edge} where we change the queue keys to use $\concretett(l) + \concretett(l,v)$ instead. The result is shown in fig. \ref{alg:relax_edge_a_star}.

\begin{figure}[hbtp]
	\setlength{\interspacetitleruled}{0pt}%
	\setlength{\algotitleheightrule}{0pt}%
	\begin{algorithm*}[H]
		\SetFuncSty{textsc}
		\DontPrintSemicolon
		\SetKwData{Q}{Q}
		\SetKwData{L}{L}

		\SetKwFunction{relaxEdge}{relaxEdge}
		\SetKwFunction{queueDeleteMin}{deleteMin}

		\SetKwData{Q}{Q}
		\SetKwData{L}{L}
		\SetKwData{D}{D}
		\SetKwData{pred}{pred}
		\SetKwArray{ds}{ds}
		\SetKwFunction{queueDeleteMin}{deleteMin}
		\SetKwFunction{queueInsert}{queueInsert}
		\SetKwFunction{setInsert}{insert}
		\SetKwFunction{queueMin}{min}
		\SetKwFunction{queueMinKey}{minKey}
		\SetKwFunction{queueDecreaseKey}{decreaseKey}
		\SetKwFunction{queueContains}{contains}
		\SetKwFunction{listInsert}{insert}
		\SetKwFunction{removeDom}{removeDominated}

		\SetKwProg{Pn}{Procedure}{:}{\KwRet}
		\Pn{\relaxEdge{(u,v), l}}{
			\If{$\breakDist(l) + \mathfunction{len}(u,v) < \restr_d$}
			{
				\D.\setInsert{$(\concretett(l) + \mathfunction{len}(u,v), \breakDist(l) + \mathfunction{len}(u,v), l)$}\;

				\If{$v \in P$}
				{
					\D.\setInsert{$(\concretett(l) + \mathfunction{len}(u,v) + \breakDist_p, 0, l)$}\;
				}

				\ForAll{ $l' \in D$ }
				{
					\If{$l'$ is not dominated by any label in \L{$v$}}
					{
						\L{$v$}.\removeDom{$l'$} \;
						\L{$v$}.\setInsert{$l'$} \;
						\Q.\queueInsert{$\concretett(l') + \concretepotential_t(l')$, l'}
					}
				}
			}
		}
	\end{algorithm*}
	\setlength{\interspacetitleruled}{2pt}%
	\setlength{\algotitleheightrule}{\algotitleheightruledefault}%

	\caption{\label{alg:relax_edge_a_star} Relaxing an edge with regard to the potential.}
\end{figure}

\subsection{Potential for One Driving Time Constraint}\label{section:potential_csp}
Given a target node $t$, the CH potential $\chpotential_t(v)$ yields a perfect estimate for the distance $\distance(v,t)$ from $v$ to $t$ without regard for driving time constraints and breaks. This trivially is a lower bound for the remaining travel time for any label at $v$. A better lower bound for the remaining travel time of a label at $v$ to $t$, including breaks due to the driving time limit, can be calculated by taking the minimum necessary amount of breaks into account. We define \minBreaks($d$) as a function which calculates the minimum amount of necessary breaks given a driving time $d$.

\begin{align}\label{eq:min_breaks}
	\minBreaks(d) = \begin{dcases}
		\ceil*{ \frac{d}{\restr_d} } - 1 & d > 0 \\
		0                                & else
	\end{dcases}
\end{align}

Simply using $\floor*{ \frac{d}{\restr_d} }$ is not sufficient since we do not need to pause for a driving time of exactly $\restr_d$. We now can calculate a lower bound for the minimum necessary break time given a driving time $d$

\begin{align}\label{eq:min_break_time}
	\minBreakTime(d) = \minBreaks(d) \cdot \restr_b
\end{align}

and finally define our node potential as

\begin{align}
	\begin{split}
		\concretepotential{'}_t(v) & = \minBreakTime(d) + \chpotential_t(v) \\
		& = \minBreakTime(d) + \distance(v,t)
	\end{split}
\end{align}

A node potential is called \emph{feasible} if it does not overestimate the distance of any edge in the graph, i.e.

\begin{align}
	\label{eq:node_potential_feasibility}
	len(u,v) - \concretepotential_t(u) + \concretepotential_t(v) \ge 0 \quad \forall (u,v) \in E
\end{align}

A feasible node potential allows us to stop the A* search when the node $t$, respectively the first label at $t$, was removed from the queue. Following counterexample of a query using the graph in Fig. \ref{fig:graph_infeasible_potential} shows that $\concretepotential{'}_t$ is not feasible. With a driving time limit of 6 and a break time of 1, the potential here will yield a value $\concretepotential_t(s) = 8$ since the potential includes the minimum required break time for a path from s to t. Consequently, with $\concretepotential{'}_t(v) = 5$ and $len(s,v) = 2$, $len(s,v) - \concretepotential{'}_t(s) + \concretepotential{'}_t(v) = -1$.

\begin{figure}[hbtp]
	\centering
	\input{figures/graph_infeasible_potential.tex}
	\caption{A graph for which the feasibility condition of equation \ref{eq:node_potential_feasibility} does not always hold with the potential $\concretepotential'$.}
	\label{fig:graph_infeasible_potential}
\end{figure}

A variant of the potential accounts for the driving time since the last break of a label $\breakDist(l)$ to calculate the minimum required break time on the $v$-$t$ path.

\begin{align}
	\begin{split}
		\concretepotential_t(l,v) & = \minBreakTime(\breakDist(l) + \chpotential(v)) +\chpotential(v) \\
		& = \minBreakTime(\breakDist(l) + \distance(v,t)) + \distance(v,t)
	\end{split}
\end{align}

Since the potential now uses information from a label $l$ with $l \in L(v)$, it no longer is a node potential but also depends on the chosen label at $v$. The feasibility definition as defined in inequality \ref{eq:node_potential_feasibility} can no longer be applied. We therefore have to show that queue keys of labels, which represent a lower bound estimate for the travel time of the entire route, can only increase over time.

\begin{lemma}\label{lemma:pot_labels_get_larger}
	Let $p = \langle s=v_0,v_1,\ldots,t=v_k \rangle$ be a path with labels $l_i$ at nodes $v_i$. Then $\concretett(l_{i-1}) + \concretepotential_t(l_{i-1},v_{i-1}) \le \concretett(l_i) + \concretepotential_t(l_i,v_i)$.
\end{lemma}

\begin{proof}
	Let $(u,v) \in E$ be an edge. The procedure \textsc{relaxEdge} in fig. \ref{alg:relax_edge_a_star} can produce two new labels at a node $v$ for each label at $u$, depending on if $v$ is a parking node. We differentiate the two cases not parking at $v$ and parking at $v$. Let $l \in L(u)$ and $l' \in L(v)$.

	Following general observations can be made:

	\begin{enumerate}
		\item $d \ge d' \implies \minBreakTime(d) \ge \minBreakTime(d')$
		\item $\minBreakTime(d + \restr_d) = \restr_b + \minBreakTime(d)$
		\item $\restr_d \ge \breakDist(l') \ge \breakDist(l) + \len(u,v) \ge \breakDist(l)$\\(line $2$ in \textsc{relaxEdge} in fig. \ref{alg:relax_edge_a_star})
		\item   $\len(u,v) - \chpotential_t(u)+ \chpotential_t(v) \ge 0$ (feasibility of the CH potential)
		\item  $\len(u,v) + \chpotential_t(v) \ge \chpotential_t(u)$
	\end{enumerate}

	We show that $\concretett(l') + \concretepotential_t(l',v) - \concretett(l) - \concretepotential_t(l,u) \ge 0$.

	\emph{Case 1: Not parking at $v$.} In this case, $\concretett(l') = \concretett(l) + \len(u,v)$ and $\breakDist(l') = \breakDist(l) + \len(u,v)$.

	\begin{align}
		\begin{split}\label{eq:label_feasibility_proof_1}
			&\concretett(l') - \concretett(l) - \concretepotential_t(l,u) + \concretepotential_t(l',v)\\
			&= \concretett(l) + \len(u,v) - \concretett(l)\\
			& \phantom{{}=1} - (\minBreakTime(\breakDist(l)+\chpotential(u)) + \chpotential(u))\\
			& \phantom{{}=1} + \minBreakTime(\breakDist(l')+\chpotential(v)) + \chpotential(v)\\
			&= \len(u,v) + \minBreakTime(\breakDist(l')+\chpotential(v))\\
			& \phantom{{}=1} - \minBreakTime(\breakDist(l)+\chpotential(u)) - \chpotential(u) + \chpotential(v)\\
			&= \len(u,v) + \minBreakTime(\breakDist(l) + \len(u,v) + \chpotential(v))\\
			& \phantom{{}=1} - \minBreakTime(\breakDist(l)+\chpotential(u)) - \chpotential(u) + \chpotential(v) \\
			&\stackrel{\text{(1. and 5.)}}{\ge} \len(u,v) + \minBreakTime(\breakDist(l) + \chpotential(u))\\
			& \phantom{{}=1} - \minBreakTime(\breakDist(l)+\chpotential(u)) - \chpotential(u) + \chpotential(v) \\
			&= \len(u,v) - \chpotential(u) + \chpotential(v)\\
			&\stackrel{\text{(4.)}}{\ge} 0
		\end{split}
	\end{align}

	\emph{Case 2: Parking at $v$.} In this case, $\concretett(l') = \concretett(l) + \len(u,v) + \restr_b$ and $\breakDist(l') = 0$.

	\begin{align}
		\begin{split}\label{eq:label_feasibility_proof_2}
			&\concretett(l') - \concretett(l) - \concretepotential_t(l,u) + \concretepotential_t(l',v)\\
			&= \concretett(l) + \len(u,v) + \restr_b - \concretett(l)\\
			& \phantom{{}=1} - (\minBreakTime(\breakDist(l) + \chpotential(u)) + \chpotential(u))\\
			& \phantom{{}=1} + \minBreakTime(\chpotential(v)) + \chpotential(v)\\
			&=  \len(u,v) + \restr_b + \minBreakTime(\chpotential(v))\\
			& \phantom{{}=1} - \minBreakTime(\breakDist(l)+\chpotential(u)) - \chpotential(u) + \chpotential(v)\\
			&\stackrel{\text{(2.)}}{=}  \len(u,v) + \minBreakTime(\restr_d + \chpotential(v))\\
			& \phantom{{}=1} - \minBreakTime(\breakDist(l)+\chpotential(u)) - \chpotential(u) + \chpotential(v)\\
			&\stackrel{\text{(1. and 3.)}}{\ge} \len(u,v) + \minBreakTime(\breakDist(l) + \len(u,v) + \chpotential(v))\\
			& \phantom{{}=1} - \minBreakTime(\breakDist(l)+\chpotential(u)) - \chpotential(u) + \chpotential(v)\\
			&\stackrel{\text{(1. and 4.)}}{\ge} \len(u,v) + \minBreakTime(\breakDist(l) + \chpotential(u))\\
			& \phantom{{}=1} - \minBreakTime(\breakDist(l)+\chpotential(u)) - \chpotential(u) + \chpotential(v)\\
			&=  \len(u,v) - \chpotential(u) + \chpotential(v)\\
			&\stackrel{\text{(4.)}}{\ge} 0
		\end{split}
	\end{align}
\end{proof}

\begin{lemma}\label{lemma:pot_lower_bound_csp}
	The sum $\concretett(l) + \concretepotential_t(l,v)$ of a label $l$ at a node $v$ is a lower bound for the travel time from $s$ to $t$ using $l$.
\end{lemma}

\begin{proof}
	Let $p = \langle s=v_0,v_1,\ldots,t=v_k \rangle$ be a path with labels $l_i$ at nodes $v_i$. With lemma \ref{lemma:pot_labels_get_larger} and $\concretepotential_t(l_k,t) = 0$ follows

	\begin{align*}
		\concretett(l_{i}) + \concretepotential_t(l_{i},v_{i}) & \le \concretett(l_{i+1}) + \concretepotential_t(l_{i+1},v_{i+1})     \\
		                                                       & \le \dots \le \concretett(l_{k}) + \concretepotential_t(l_{k},v_{k}) \\
		                                                       & = \concretett(p)
	\end{align*}

\end{proof}

\begin{theorem}\label{theorem:pot_stop_criterion}
	The search can be stopped when the first label at $t$ is removed from the queue.
\end{theorem}

\begin{proof}
	When a label $l_t$ at $t$ is removed from the queue during an $s$-$t$ query, all remaining labels $l$ at nodes $v$ in the queue fulfill $\concretett(t) + \concretepotential_t(l_t,t) \le \concretett(v) + \concretepotential_t(l,v)$. The same holds for all labels which will be inserted into the queue at a later point in time (lemma \ref{lemma:pot_labels_get_larger}). Assume that $\concretett(l_t)$ is not the shortest route from $s$ to $t$ with time $\traveltime(s,t)$. Then, a shorter route exists which uses at least one unsettled label $l \in L(v)$ at a node $v$. With lemma \ref{lemma:pot_lower_bound_csp} and $\concretepotential_t(l_t,t) = 0$ follows $\concretett(t) = \concretett(t) + \concretepotential_t(l_t,t) \le \concretett(v) + \concretepotential_t(l,v) \le \concretett(p)$ which contradicts the assumption that $p$ yields a shorter $s$-$t$ travel time. Therefore, it must be $\concretett(l_t) = \traveltime(s,t)$ when $l_t$ was removed from the queue and the search can be stopped.
\end{proof}

\section{Multiple Driving Time Constraints\label{section:n_csp}}
Dijkstra's algorithm with one driving time constraint (1-DTC) can easily be adapted to handle multiple driving time constraints $\restr_i$. With $n=|\restrset|$ driving time constraints, a label $l$ now contains the total travel time $\concretett(l)$ and $n$ driving time values $\breakDist_1(l), \ldots , \breakDist_n(l)$. Each value $\breakDist_i(l)$ represents the driving time since the last break at a node $v$ with break time $\breakTime(v) \ge \restr_{i,b}$. Pausing at a node occurs with one of the available break times $\restr_{i,b}$ of a driving time constraint $\restr_i \in \restrset$. Pausing with an arbitrary break time is permitted but yields longer travel times and no advantage and is therefore ignored. When a route breaks at $v$ for a time $\restr_{i,b}$, the corresponding label $l \in L(v)$ has $\breakDist(l) = 0$ for all $0 < j \le i$ since the breaks with shorter break times are included in the longer break. In the following, we redefine the fundamental concepts of section \ref{sec:dijkstra_csp} for multiple driving time constraints.

\paragraph{Label Propagation}
Label propagation simply extends the component-wise addition of the edge weight. Let $l \in L(u)$ be a label at $u$ and $(u,v) = e \in E$, then $l$ can be propagated to $v$ resulting in a label $l'$ with $\concretett(l') = \concretett(l) + \mathfunction{len}(e)$, $\breakDist_i(l') = \breakDist_i(l) + \mathfunction{len}(e)$ $\forall\ 1 \le i \le |\restrset|$, and $\pred(l') = l$.

\paragraph{Label Pruning}
The pruning rule for driving time constraints is generalized in a similar way. A label is discarded if $\breakDist_i(l) > \restr_{i,d}$ for any $i$ with $0 < i \le |\restrset|$.


\paragraph{Label Dominance}
Label dominance can be generalized to multiple driving time constraints as follows.

\begin{definition}[Label Dominance]
	A label $l \in L(v)$ dominates another label $l' \in L(v)$ if $\concretett(l') \ge \concretett(l)$ and $\breakDist_i(l') \ge \breakDist_i(l)$ $\forall\ 1 \le i \le |\restrset|$.
\end{definition}

\subsection{Potential for Multiple Driving Time Constraints\label{section:potential_n_csp}}
TODO: Rewrite for only two dtc?

In section \ref{section:potential_csp} we defined the potential $\concretepotential_t(l,v)$ to extend Dijkstra's algorithm with one driving time constraint to a goal-directed search using the A* algorithm. We will now generalize $\concretepotential_t$ for the use with an arbitrary number of driving time constraints.

In equation \refeq{eq:min_breaks} we used the distance $\distance(v,t)$ without regard for pausing from $v$ to $t$ and the driving time $\breakDist(l)$ since the last break on the route to calculate a lower bound for the amount of necessary breaks until we reach the target node. We now have to calculate the lower bound with respect to all driving time constraints. How many breaks of which duration do we need at least to comply with all driving time constraints $\restr_i$? For longer driving time constraints, we will always need a greater or equal amount of breaks than for shorter driving time constraints since they have a longer maximum allowed driving time $\restr_{i,d}$. At the same time, a break of length $\restr_{i,b}$ will also include breaks of lengths $\restr_{j,b}$ with $j < i$. We start with calculating the amount of necessary breaks $\minBreaks_i(d)$, given a driving time $d$, for all constraints $\restr_i$ independently.

\begin{align}\label{eq:min_breaks_n}
	\minBreaks_i(d) = \begin{dcases}
		\ceil*{ \frac{d}{\restr_{i,d}} } - 1 & d > 0 \\
		0                                    & else
	\end{dcases}
\end{align}

Consider the example graph in fig. \ref{fig:graph_short_long_break} with two driving time constraints with permitted driving times of $4$ and $9$. Since the distance $\distance(s,t)$ is $10$, a route must have at least one long and two short breaks. If the long break is made at $u$, only one additional short break must be made at $w$. The long break made one shorter break obsolete. To obtain a lower bound for the amount of breaks for a constraint $\restr_i$, we therefore must subtract the minimum amount of longer breaks being made on the route.

\begin{figure}[hbtp]
	\centering
	\input{figures/graph_short_long_break.tex}
	\caption{An example graph where, depending on the driving time constraints, a long break at can render a short break obsolete.}
	\label{fig:graph_short_long_break}
\end{figure}

This is an optimistic assumption since not in all cases a longer break spares a shorter break. Revisit the example graph of fig. \ref{fig:graph_short_long_break} with permitted driving times of $4$ and $5$. We still need one long and two short breaks, but the long break now must take place at $v$ while the short breaks must take place at $u$ and $w$. The long break did not spare a short break. Since we are searching for a lower bound for the amount of breaks, optimistic assumptions are necessary. Given a label $l \in L(v)$, the lower bound estimate for the remaining number of breaks of length $c_{i,b}$ on the route to $t$ then becomes

\begin{align}\label{eq:number_breaks_sum}
	\breakEstimate_i(l,v)  =\begin{dcases}
		\parbox[t]{.55\textwidth}{$\minBreaks_i(\breakDist_i(l) + \chpotential_t(v))$ \\\phantom{{}=1}$- \sum_{j=i+1}^{n}{\breakEstimate_j(l,v)}$} & 0 < i < n \\
		\minBreaks_n(\breakDist_n(l) + \chpotential_t(v)) & i=n
	\end{dcases}
\end{align}

Since we subtract all break estimates for break times greater than $c_{i,b}$ to obtain the estimate for $c_{i,b}$, we can just use

\begin{align}\label{eq:break_estimate_n}
	\breakEstimate_i(l,v) = \begin{dcases}
		\parbox[t]{.55\textwidth}{$\minBreaks_i(\breakDist_i(l) + \chpotential_t(v))$ \\\phantom{{}=1}$- \minBreaks_{i+1}(\breakDist_{i+1}(l) + \chpotential_t(v))$} & 0 < i < n \\
		\minBreaks_n(\breakDist_n(l) + \chpotential_t(v)) & i=n
	\end{dcases}
\end{align}

We now can calculate a lower bound estimate for the remaining necessary break time on the route to $t$ for two driving time constraints.

\begin{align}\label{eq:rem_break_time_n}
	\begin{split}
		\remBreak(l,v) & = \sum_{i=1}^n{\breakEstimate_i(l,v)} \cdot \restr_{i,b}
	\end{split}
\end{align}

Finally, the lower bound potential for a label $l \in L(v)$ and a target node $t$ becomes

\begin{align}\label{eq:multiple_breaks_pot}
	\begin{split}
		\concretepotential_t(l,v) & =\remBreak(l,v) + \chpotential(v,t)\\
		&= \remBreak(l,v) + \distance(v,t)
	\end{split}
\end{align}

If queue keys still cannot decrease when propagating labels, lemma \ref{lemma:pot_lower_bound_csp} and theorem \ref{theorem:pot_stop_criterion} follow as a consequence. We follow the outline of the proof of lemma \ref{lemma:pot_labels_get_larger} and therefore revisit the procedure \textsc{relaxEdge} at an edge $(u,v) \in E$ with a label $l \in L(u)$ and a new label $l' \in L(v)$.

\begin{lemma}
	Lemma \ref{lemma:pot_labels_get_larger} still holds for two driving time constraints.
\end{lemma}

\begin{proof}
	There now are three cases to differentiate: not parking at $v$, short break at $v$, and long break at $v$.

	Following general observations can be made in an addition to the proof of lemma \ref{lemma:pot_labels_get_larger}:

	\begin{enumerate}
		\setcounter{enumi}{5}
		\item $d \ge d' \implies \minBreaks_i(d) \ge \minBreaks_i(d')$ (adaption of 1.)
		\item $\minBreaks_i(d + \restr_{i,d}) = 1 + \minBreaks_i(d)$ (adaption of 2.)
		\item $\restr_{i,d} \ge \breakDist_i(l') \ge \breakDist_i(l) + \len(u,v) \ge \breakDist_i(l)$ (adaption of 3.)
		      % \item Propagating a label $l \in L(u)$ to obtain a label $l' \in L(v)$ $\implies$ $\remBreak(l',v) \ge \remBreak(l,u)$ (6. and non-negative edge weights)
		      % \item $d \ge d' \implies \breakEstimate(d) \ge \breakEstimate(d')$
		      % \item $\breakEstimate_i(d + \restr_{i,d}) \ge \restr_{i,b} + \breakEstimate_i(d)$ (adaption of 2.)
		      % \item $\restr_{i,d} \ge \breakDist_i(l') \ge \breakDist_i(l) + \len(u,v) \ge \breakDist_i(l)$ (adaption of 3.)
		      % \item Propagating a label $l \in L(u)$ to obtain a label $l' \in L(v)$ $\implies$ $\remBreak(l',v) \ge \remBreak(l,u)$ (6. and 7.)
	\end{enumerate}

	\emph{Case 1: Not parking at $v$}. In this case, $\concretett(l') = \concretett(l) + \len(u,v)$ and $\breakDist_i(l') = \breakDist_i(l) + \len(u,v)$.

	\begin{align}
		\begin{split}\label{eq:label_n_feasibility_proof_1}
			&\concretett(l') - \concretett(l) - \concretepotential_t(l,u) + \concretepotential_t(l',v)\\
			&= \concretett(l) + \len(u,v) - \concretett(l)\\
			& \phantom{{}=1} - (\remBreak(l,u) + \chpotential(u)) + (\remBreak(l',v) + \chpotential(v))\\
			&= \len(u,v) - \remBreak(l,u) + \remBreak(l',v) - \chpotential(u) + \chpotential(v)\\
			&= \len(u,v) + \breakEstimate_2(l',v) \cdot \restr_{2,b} + \breakEstimate_1(l',v) \cdot \restr_{1,b}\\
			& \phantom{{}=1} - \remBreak(l,u) - \chpotential(u) + \chpotential(v)\\
			&= \len(u,v) + \minBreaks_2(\breakDist_2(l) + \len(u,v) + \chpotential_t(v)) \cdot \restr_{2,b}\\
			& \phantom{{}=1} + (\minBreaks_1(\breakDist_1(l) + \len(u,v) + \chpotential_t(v))\\
			& \phantom{{}=1} - \minBreaks_2(\breakDist_2(l) + \len(u,v) + \chpotential_t(v))) \cdot \restr_{1,b}\\
			& \phantom{{}=1} - \remBreak(l,u) - \chpotential(u) + \chpotential(v)\\
			&\stackrel{\text{(5. and 6.)}}{\ge} \len(u,v)  + \minBreaks_2(\breakDist_2(l) + \chpotential_t(u)) \cdot \restr_{2,b}\\
			& \phantom{{}=1} + (\minBreaks_1(\breakDist_1(l) + \chpotential_t(u))\\
			& \phantom{{}=1} - \minBreaks_2(\breakDist_2(l) + \chpotential_t(u))) \cdot \restr_{1,b}\\
			& \phantom{{}=1} - \remBreak(l,u) - \chpotential(u) + \chpotential(v)\\
			&= \len(u,v) +  \remBreak(l,u) - \remBreak(l,u) - \chpotential(u) + \chpotential(v)\\
			&= \len(u,v) - \chpotential(u) + \chpotential(v)\\
			&\stackrel{\text{(4.)}}{\ge} 0
		\end{split}
	\end{align}

	\emph{Case 2: Short break at $v$}. In this case, $\concretett(l') = \concretett(l) + \len(u,v) + \restr_b$ and $\breakDist_1(l') = 0$ and $\breakDist_2(l') = \breakDist_2(l) + \len(u,v)$.

	\begin{align}
		\begin{split}\label{eq:label_n_feasibility_proof_2}
			&\concretett(l') - \concretett(l) - \concretepotential_t(l,u) + \concretepotential_t(l',v)\\
			&= \concretett(l) + \len(u,v) + \restr_{1,b} - \concretett(l)\\
			& \phantom{{}=1} - (\remBreak(l,u) + \chpotential(u)) + (\remBreak(l',v) + \chpotential(v))\\
			&= \len(u,v) + \restr_{1,b} + \remBreak(l',v)\\
			& \phantom{{}=1} - \remBreak(l,u) - \chpotential(u)  + \chpotential(v)\\
			&= \len(u,v) + \restr_{1,b} + \breakEstimate_2(l',v) \cdot \restr_{2,b} + \breakEstimate_1(l',v) \cdot \restr_{1,b}\\
			& \phantom{{}=1} - \remBreak(l,u) - \chpotential(u)  + \chpotential(v)\\
			&= \len(u,v) + \restr_{1,b} + \minBreaks_2(\breakDist_2(l) + \len(u,v) + \chpotential_t(v)) \cdot \restr_{2,b}\\
			& \phantom{{}=1} + (\minBreaks_1(0 + \chpotential_t(v))\\
			& \phantom{{}=1} - \minBreaks_2(\breakDist_2(l) + \len(u,v) + \chpotential_t(v))) \cdot \restr_{1,b}\\
			& \phantom{{}=1} - \remBreak(l,u) - \chpotential(u) + \chpotential(v)\\
			&\stackrel{\text{(7.)}}{ =} \len(u,v) + \minBreaks_2(\breakDist_2(l) + \len(u,v) + \chpotential_t(v)) \cdot \restr_{2,b}\\
			& \phantom{{}=1} + (\minBreaks_1(r_{1,d} + \chpotential_t(v))\\
			& \phantom{{}=1} - \minBreaks_{2}(\breakDist_{2}(l) + \len(u,v) + \chpotential_t(v))) \cdot \restr_{1,b} \\
			& \phantom{{}=1} - \remBreak(l,u) - \chpotential(u) + \chpotential(v)\\
			&\stackrel{\text{(6. and 8.)}}{\ge} \len(u,v) + \minBreaks_2(\breakDist_2(l) + \len(u,v) + \chpotential_t(v)) \cdot \restr_{2,b}\\
			& \phantom{{}=1} + (\minBreaks_1(\breakDist_1(l) + \len(u,v) + \chpotential_t(v))\\
			& \phantom{{}=1} - \minBreaks_{2}(\breakDist_{2}(l) + \len(u,v) + \chpotential_t(v))) \cdot \restr_{1,b} \\
			& \phantom{{}=1} - \remBreak(l,u) - \chpotential(u) + \chpotential(v)\\
			&\stackrel{\text{(5. and 6.)}}{\ge} \len(u,v)  + \minBreaks_2(\breakDist_2(l) + \chpotential_t(u)) \cdot \restr_{2,b}\\
			& \phantom{{}=1} + (\minBreaks_1(\breakDist_1(l) + \chpotential_t(u))\\
			& \phantom{{}=1} - \minBreaks_2(\breakDist_2(l) + \chpotential_t(u))) \cdot \restr_{1,b}\\
			& \phantom{{}=1} - \remBreak(l,u) - \chpotential(u) + \chpotential(v)\\
			&= \len(u,v) +  \remBreak(l,u) - \remBreak(l,u) - \chpotential(u) + \chpotential(v)\\
			&= \len(u,v) - \chpotential(u) + \chpotential(v)\\
			&\stackrel{\text{(4.)}}{\ge} 0
		\end{split}
	\end{align}


	\emph{Case 3: Long break at $v$}. In this case, $\concretett(l') = \concretett(l) + \len(u,v) + \restr_b$ and $\breakDist_i(l') = 0$.

	\begin{align}
		\begin{split}\label{eq:label_n_feasibility_proof_3}
			&\concretett(l') - \concretett(l) - \concretepotential_t(l,u) + \concretepotential_t(l',v)\\
			&= \concretett(l) + \len(u,v) + \restr_{2,b} - \concretett(l)\\
			& \phantom{{}=1} - (\remBreak(l,u) + \chpotential(u)) + (\remBreak(l',v) + \chpotential(v))\\
			&= \len(u,v) + \restr_{2,b} + \remBreak(l',v)\\
			& \phantom{{}=1} - \remBreak(l,u) - \chpotential(u)  + \chpotential(v)\\
			&= \len(u,v) + \restr_{2,b} + \breakEstimate_2(l',v) \cdot \restr_{2,b} + \breakEstimate_1(l',v) \cdot \restr_{1,b}\\
			& \phantom{{}=1} - \remBreak(l,u) - \chpotential(u)  + \chpotential(v)\\
			&= \len(u,v) + \restr_{2,b} + \minBreaks_2(0 + \chpotential_t(v)) \cdot \restr_{2,b}\\
			& \phantom{{}=1} + (\minBreaks_1(0 + \chpotential_t(v)) - \minBreaks_2(0 + \chpotential_t(v))) \cdot \restr_{1,b}\\
			& \phantom{{}=1} - \remBreak(l,u) - \chpotential(u) + \chpotential(v)\\
			&\stackrel{\text{(7.)}}{=} \len(u,v) + \minBreaks_2(\restr_{2,d}  + \chpotential_t(v)) \cdot \restr_{2,b}\\
			& \phantom{{}=1} + (\minBreaks_1(\restr_{1,d}  + \chpotential_t(v)) - \minBreaks_2(\restr_{2,d} + \chpotential_t(v))) \cdot \restr_{1,b}\\
			& \phantom{{}=1} - \remBreak(l,u) - \chpotential(u) + \chpotential(v)\\
			&\stackrel{\text{(6. and 8.)}}{\ge} \len(u,v) + \minBreaks_2(\breakDist_2(l) + \len(u,v) + \chpotential_t(v)) \cdot \restr_{2,b}\\
			& \phantom{{}=1} + (\minBreaks_1(\breakDist_1(l) + \len(u,v) + \chpotential_t(v))\\
			& \phantom{{}=1} - \minBreaks_{2}(\breakDist_2(l) + \len(u,v) +\chpotential_t(v))) \cdot \restr_{1,b} \\
			& \phantom{{}=1} - \remBreak(l,u) - \chpotential(u) + \chpotential(v)\\
			&\stackrel{\text{(5. and 6.)}}{\ge} \len(u,v)  + \minBreaks_2(\breakDist_2(l) + \chpotential_t(u)) \cdot \restr_{2,b}\\
			& \phantom{{}=1} + (\minBreaks_1(\breakDist_1(l) + \chpotential_t(u))\\
			& \phantom{{}=1} - \minBreaks_2(\breakDist_2(l) + \chpotential_t(u))) \cdot \restr_{1,b}\\
			& \phantom{{}=1} - \remBreak(l,u) - \chpotential(u) + \chpotential(v)\\
			&= \len(u,v) +  \remBreak(l,u) - \remBreak(l,u) - \chpotential(u) + \chpotential(v)\\
			&= \len(u,v) - \chpotential(u) + \chpotential(v)\\
			&\stackrel{\text{(4.)}}{\ge} 0
		\end{split}
	\end{align}

\end{proof}

\section{Bidirectional Goal-Directed Search with Multiple Driving Time Constraints\label{sec:bidir_astar}}
We now extend the goal-directed approach of section \ref{section:potential_n_csp} to a bidirectional approach. Our algorithm will consist of a forward search from $s$ in $\overrightarrow{G}$ and a backward search from $t$ in $\overleftarrow{G}$. The distances of the forward and backward search are combined at nodes were which were settled by both searches. We therefore introduce a concept to merge the label sets of backward and forward search to find the best currently known and valid path using information of both searches. Since we aim to stop the search as early as possible, we have to decide on a stopping criterion which allows the search to stop way before the forward search settles the target node $t$ or the backward search settles $s$. The correctness of the stopping criterion is closely tied to the potential of section \ref{section:potential_n_csp}.

The input of the search remains a graph $G=(V,E,\mathfunction{len})$, a set of parking nodes $P \subseteq V$, a set of driving time constraints $\restrset$, and start and target nodes $s,t \in V$. There are two potentials $\overrightarrow{\concretepotential_t}$ and $\overleftarrow{\concretepotential}_s$ which we call the forward and the backward potential. The forward potential yields lower bounds for the remaining travel time of a label to $t$ in $\overrightarrow{G}=G$. The backward potential yields lower bounds for the remaining travel time of a label to $s$ in $\overleftarrow{G}$. The forward search then is a normal A* search on $\overrightarrow{G}$ with start node $s$ and target node $t$ and the backward search is a normal A* search on $\overleftarrow{G}$ with start node $t$ and target node $s$. Each search owns a queue of labels $\overrightarrow{Q}$ and $\overleftarrow{Q}$ and a label set $\overrightarrow{L}(v)$, respectively $\overleftarrow{L}(v)$ for each $v \in V$.

During the search, forward and backward search alternately settle nodes until the stopping criterion is met, one search completed the search by itself, or the queues ran empty. We hold the tentative value for $\traveltime(s,t)$ in a variable $\tenttraveltime(s,t)$ which we initialize with $\infty$ before settling the first node. When forward or backward search settles a node $v$, they additionally check if the label set of the other search at $v$ contains any settled labels. If this is the case, forward and backward search met at this node. We then search for the combination of labels which yields the shortest valid route between $s$ and $t$ via $v$. In other words, we want to find the labels $l \in \overrightarrow{L}(v)$ and $m \in \overleftarrow{L}(v)$ which minimize $\concretett(l) + \concretett(m)$ and for which $\breakDist_1(l) + \breakDist_1(m) < \restr_{1,d}$ and $\breakDist_1(l) + \breakDist_1(m) < \restr_{2,d}$. If the resulting distance for an $s$-$t$ path via $v$ is smaller than the previously known minimum tentative distance $\tenttraveltime(s,t)$, we update $\tenttraveltime(s,t)$ accordingly. We stop the forward search if the minimum key of $\overrightarrow{Q}$ is greater than $\tenttraveltime(s,t)$ and stop the backward search when the minimum key of $\overleftarrow{Q}$ is greater than $\tenttraveltime(s,t)$.

\begin{theorem}
	At the point in time when forward and backward search have stopped, $\tenttraveltime(s,t) = \traveltime(s,t)$. In other words, when the search stops, $\tenttraveltime(s,t)$ equals the minimum travel time from $s$ to $t$ which complies with the driving time constraints $\restrset$.
\end{theorem}

\begin{proof}
	We show that when the search stops, all valid $s$-$t$ routes $q$ which comply with the driving time constraints $\restrset$ and which were not found yet yield a larger travel time $\concretett(q)$ than the current $\tenttraveltime(s,t)$. This also implies that if $\tenttraveltime(s,t) = \infty$ at the point in time when the search stops, there exist no paths from $s$ to $t$.

	Since the search stops when the minimum keys of $\overrightarrow{Q}$ and $\overleftarrow{Q}$ are both greater than $\tenttraveltime(s,t)$, all labels $l$ which will be settled by continuing the search have a greater distance $\concretett(l)$. Therefore, if any new connection between forward and backward search which complies with the driving time constraints will be found, its distance will be greater than $\tenttraveltime(s,t)$.

	The shortest path with travel time $\traveltime(s,t)$ consists of two subpaths of forward and backward search which were connected at a node $v$. There exist label $l \in \overrightarrow{L}$ and $m \in \overleftarrow{L}$ with $\concretett(l) + \concretett(m) = \traveltime(s,t)$. Each label is the result of a unidirectional search from $s$, respectively from $t$. In section \ref{sec:dijkstra_csp_correctness} we proved that a unidirectional search can be stopped when the first label at its target node was removed from the queue. Since $l$ and $m$ are both smaller or equal to $\tenttraveltime(s,t)$ and both queue keys of forward and backward queue are greater, $l$ and $m$ where already removed from the respective queue. Therefore, we know that $\overrightarrow{L}(v)$ and $\overleftarrow{L}(v)$ contain the labels with the shortest distance from $s$ to $v$, respectively from $t$ to $v$. Consequently, when the second of both labels was settled at $v$, $\traveltime(s,t)$ was updated with the value $\concretett(l) + \concretett(m)$.
\end{proof}

\section{Goal-Directed Core Contraction Hierarchy Search}
Given a graph $G = (V,E,\mathfunction{len})$, we construct a core contraction hierarchy in which the core contains all the parking nodes $P \subseteq V$. We denote the set of uncontracted core nodes as $C \subseteq V$. It is $P \subseteq C$. The set of nodes $V$ therefore is split into a set of core nodes $C$ and a set of contracted nodes $V_{CH} = V \setminus C$. The graph $G_{CH} = (V_{CH},E_{CH},\mathfunction{len})$ with nodes $V_{CH}$ and edges $E_{CH} = \{(u,v) \in E \colon u,v \in V_{CH}\}$ therefore is a valid contraction hierarchy. It contains only contracted nodes and edges between those nodes. Thus, $E_{CH}$ contains only upward edges. The graph $G_{C} = (V \setminus V_{CH},E \setminus E_{CH},\mathfunction{len})$ is called the core graph.

The goal-directed core CH query reuses the bidirectional, goal-directed approach of section \ref{sec:bidir_astar} on a modified forward graph $\overrightarrow{G}^*$ and a modified backward graph $\overleftarrow{G}^*$. The forward graph $\overrightarrow{G}^* = (V,\overrightarrow{E}^*,\mathfunction{len})$ consists of the forward graph of the contraction hierarchy $\overrightarrow{G}_{CH}$, extended by the core graph $G_C$. It is $\overrightarrow{E}^* = \overrightarrow{E}_{CH} \cup E_C $. Equivalently, the backward graph is defined as $\overleftarrow{G}^* = (V,\overleftarrow{E}^*,\overleftarrow{\mathfunction{len}})$ with $\overleftarrow{E}^* = \overleftarrow{E}_{CH} \cup E_C$ and $\overleftarrow{\mathfunction{len}}(u,v) = \mathfunction{len}(v,u)$.

The bidirectional query in $G^*$ consequently consists of a forward search from $s$ in $\overrightarrow{G}^*$ and backward search from $t$ in $\overleftarrow{G}^*$. Each search consists of two parts, an upward search in $G_{CH}$ and a search in $G_C$. A search may begin at a core node skip the upward part, it also may not reach the core graph at all and only perform the CH upward search.

The stopping criterion of the bidirectional search must take into account that the graph $G^*$ contains the contraction hierarchy $G_{CH}$. The common stopping criterion for $s$-$t$ queries in a CH is to stop the search if the minimum queue key of both queues $\overrightarrow{Q}$ and $\overleftarrow{Q}$ is greater or equal to the tentative minimum distance $\distance(s,t)$ \cite{geisberger:2012}. Since this criterion is a valid stopping criterion for the bidirectional A* algorithm, we can use it for our combination of CH and bidirectional A*.

\subparagraph{Correctness}
\begin{proof}
	We simply derive the correctness of the core contraction hierarchy search from the correctness of a CH search and the correctness of the bidirectional A*. The label set of a node $v \in C_{CH}$ can never contain more than one label for the forward search and one label for the backward search. Let $C'$ be the set of nodes which are reachable from another core node, i.e. $C' = C \cup \{v \colon (u,v) \in E \wedge u \in C\}$.

	\emph{Case 1: Neither forward nor backward search settle a node in $C'$.} No parking is involved since $P \subseteq C$. The query constitutes a simple CH query without labels, extended by pruning with the driving time constraints and goal-direction. The correctness directly follows from the correctness of the bidirectional A* algorithm with driving time constraints as shown in section \ref{section:n_csp}.

	\emph{Case 2: Forward or backward search settle a node in $C'$, but not both.} No valid $s$-$t$ route exists per definition of $C'$. The correctness of the query is trivial since forward and backward search cannot settle a common node.

	\emph{Case 3: Both forward and backward search settle a node in $C'$.} The query continues in the core as a bidirectional goal-directed search as described in section \ref{section:n_csp}. Since the chosen stopping criterion is valid for this case, the result will be correct.
\end{proof}
