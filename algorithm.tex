%% content.tex
%%

%% ==============
\chapter{Algorithm}
\label{ch:Algorithm}
%% ==============
In this chapter, we introduce a labeling algorithm which solves the long-haul truck driver routing problem. We then describe extensions of the base algorithm to achieve better runtimes on road networks in practice. At first, we will restrict the problem to one driving time constraint for simplicity and drop that constraint later.

\section{Dijkstra's Algorithm with One Driving Time Constraint}
Dijkstra's algorithm solves the shortest path problem by maintaining a queue $Q$ of nodes with ascending tentative distance from the starting node $s$, and iteratively settling the node with the smallest distance. When Dijkstra settles a node $u$, it tests if the distance to all neighbor nodes $v$ with $(u,v) \in E$ can be improved by choosing the current node as a predecessor. We say it \emph{relaxes} all edges $(u,v) \in E$. The search can be stopped if the target node $t$ was removed from the queue. TODO REFERENCE PROOF

We will adapt Dijkstra's algorithm for solving the long-haul truck driver routing problem with one driving time constraint $r$ and abbreviate this restriction of the problem \emph{1-DTC}. While Dijkstra's algorithm manages a queue of nodes and assigns each node one tentative distance, our algorithm manages a queue $Q$ of labels and a set $L(v)$ of labels for each node $v \in V$.

Labels represent a possible path, respectively a possible solution for a query from $s$ to the node they belong to. A label $l$ contains

\begin{itemize}
	\item $d_0(l)$, the total travel time from the starting node $s$
	\item $d_1(l)$, the driving time since the last pause
	\item $\pred(l)$, its preceding label
\end{itemize}

\subsection{Settling a Label}
In contrast to Dijkstra, the search \emph{settles} a label $l \in L(u)$ in each iteration instead of a node $u$. When settling a label, the search first removes $l$ from the queue. Similar to Dijkstra, it then relaxes all edges $(u,v) \in E$ with $l \in L(u)$ as shown in fig. \ref{alg:settle_next_label}.

\begin{figure}[hbtp]
	\setlength{\interspacetitleruled}{0pt}%
	\setlength{\algotitleheightrule}{0pt}%
	\begin{algorithm*}[H]
		\SetFuncSty{textsc}
		\DontPrintSemicolon
		\SetKwData{Q}{Q}
		\SetKwData{L}{L}

		\SetKwFunction{settleNextLabel}{settleNextLabel}
		\SetKwFunction{relaxEdge}{relaxEdge}
		\SetKwFunction{queueDeleteMin}{deleteMin}

		\SetKwProg{Pn}{Procedure}{:}{\KwRet}
		\Pn{\settleNextLabel{}}{
			$l \leftarrow$ \Q.\queueDeleteMin{} \;
			\BlankLine

			\ForAll{ $(u,v) \in E$ }
			{
				\relaxEdge{$(u,v),l$}
			}
		}
	\end{algorithm*}
	\setlength{\interspacetitleruled}{2pt}%
	\setlength{\algotitleheightrule}{\algotitleheightruledefault}%

	\caption{\label{alg:settle_next_label}Settling a label $l \in L(u)$ removes the label from the queue and relaxes all the outgoing edges of $u$.}
\end{figure}

Relaxing an edge consists of the three steps label \emph{propagation}, \emph{pruning} and \emph{dominance} checks.

\paragraph{Label Propagation.}
Labels can be propagated along edges. Let $l \in L(u)$ be a label at $u$ and $(u,v) = e \in E$, then $l$ can be propagated to $v$ resulting in a label $l'$ with $d_0(l') = d_0(l) + \omega(e)$, $d_1(l') = d_1(l) + \omega(e)$, and $\pred(l') = l$.

\paragraph{Label Pruning.}
After propagating a label, we discard the label if it violates the driving time constraint $r$. That is, if $d_1(l) \ge r_d$.


\paragraph{Label Dominance}
In general, it is no longer clear when a label presents a better solution than another label since it now contains two distance values. A label $l$ at a node $v$ might represent a path with a shorter travel time from $s$ to $v$ than another label $m$, but a shorter remaining driving time budget $r_d - d_1(l)$. The label $l$ yields a better solution for a query $s$-$v$, but this does not imply that it is part of a better solution for a query from $s$ to $t$. It might not even yield a path to $t$ at all while $m$ reaches the target due to the greater remaining driving time budget. In one case we can proof that a label $l \in L(v)$ cannot yield a better solution than a label $m \in L(v)$. We say $m$ \emph{dominates} $l$.

\begin{definition}[Label Dominancef for 1-DTC]
	A label $l \in L(v)$ dominates another label $m \in L(v)$ if $d_0(m) \ge d_0(l)$ and $d_1(m) \ge d_1(l)$.
\end{definition}

If a label $l \in L(v)$ is dominated by another label $m \in L(v)$, then $m$ represents a path from $s$ to $t$ with a shorter or equal total travel time and longer remaining driving time budget until the next pause. Therefore, in each solution which uses the label $l$, $l$ can trivially be replaced by the label $m$. The solution will still comply with the driving time constraint $r$ and yield a shorter or equal total travel time, so we are allowed to simply discard dominated labels in our search.

\begin{definition}[Pareto-Optimal Label]
	A label $l \in L(v)$ is pareto-optimal if it is not dominated by any other label $m \in L(v)$.
\end{definition}

We will only add a label $l$ to a label set $L(v)$ if it is pareto-optimal. Labels $m \in L(v)$ are then removed from $L(v)$ if $l$ dominates them. $L(v)$ therefore is the set of pareto-optimal solutions at $v$. In fig. \ref{alg:remove_dominated} we define the procedure \textsc{removeDominated($l$)} as a label set operation.

\begin{figure}[hbtp]
	\setlength{\interspacetitleruled}{0pt}%
	\setlength{\algotitleheightrule}{0pt}%
	\begin{algorithm*}[H]
		\SetFuncSty{textsc}
		\SetKwFor{ForAll}{forall}{do}
		\DontPrintSemicolon
		\SetKwData{L}{L}

		\SetKwFunction{removeDominated}{removeDominated}
		\SetKwFunction{queueRemove}{remove}

		\SetKwProg{Pn}{Procedure}{:}{\KwRet}
		\Pn{\removeDominated{$l$}}{
			\ForAll{$m \in L$}
			{
				\If{\text{$l$ dominates $m$}}{
					\L.\queueRemove($m$)\;
				}
			}
		}
	\end{algorithm*}
	\setlength{\interspacetitleruled}{2pt}%
	\setlength{\algotitleheightrule}{\algotitleheightruledefault}%

	\caption{\label{alg:remove_dominated}The operation which is defined on a label set $L$, removes all labels from the set which are dominated by the label $l$.}
\end{figure}

We now use \textsc{removeDominated} to define the procedure \textsc{relaxEdge$'$} as described in fig. \ref{alg:relax_edge_no_p} which propagates a label along an edge and updates the neighbor node's label set if necessary.

\begin{figure}[hbtp]
	\setlength{\interspacetitleruled}{0pt}%
	\setlength{\algotitleheightrule}{0pt}%
	\begin{algorithm*}[H]
		\SetFuncSty{textsc}
		\DontPrintSemicolon
		\SetKwData{Q}{Q}
		\SetKwData{L}{L}

		\SetKwFunction{relaxEdgeNoP}{relaxEdge$'$}
		\SetKwFunction{queueDeleteMin}{deleteMin}

		\SetKwData{Q}{Q}
		\SetKwData{dist}{d}
		\SetKwData{L}{L}
		\SetKwData{pred}{pred}
		\SetKwArray{ds}{ds}
		\SetKwFunction{queueDeleteMin}{deleteMin}
		\SetKwFunction{queueInsert}{insert}
		\SetKwFunction{queueMin}{min}
		\SetKwFunction{queueMinKey}{minKey}
		\SetKwFunction{queueDecreaseKey}{decreaseKey}
		\SetKwFunction{queueContains}{contains}
		\SetKwFunction{listInsert}{insert}
		\SetKwFunction{removeDom}{removeDominated}

		\SetKwProg{Pn}{Procedure}{:}{\KwRet}
		\Pn{\relaxEdgeNoP{(u,v), l}}{
			\If{$d_1(l) + \omega(u,v) < r_d$}
			{
				$l' \leftarrow \{(d_0(l) + \omega(u,v), d_1(l) + \omega(u,v)), l\}$\;
				\If{$l'$ is not dominated by any label in \L{$v$}}
				{
					\L{$v$}.\removeDom{$l'$} \;
					\L{$v$}.\queueInsert{$l'$} \;
					\Q.\queueInsert{$l'$}
				}
			}
		}
	\end{algorithm*}
	\setlength{\interspacetitleruled}{2pt}%
	\setlength{\algotitleheightrule}{\algotitleheightruledefault}%

	\caption{\label{alg:relax_edge_no_p}Relaxing an edge $(u,v) \in E$ when settling a label $l \in L(u)$.}
\end{figure}

\subsection{Parking at a Node}
The procedure \textsc{relaxEdge$'$} does not account for parking nodes. When propagating a label $l \in L(u)$ along an edge $(u,v) \in E$ and $v \in P$ then we have to consider pausing at $v$. Since we do not know if pausing at $v$ or continuing without a pause is the better solution, we generate both labels and them to label set $L(v)$ and the queue $Q$ as defined in fig. \ref{alg:relax_edge}.

\begin{figure}[hbtp]
	\setlength{\interspacetitleruled}{0pt}%
	\setlength{\algotitleheightrule}{0pt}%
	\begin{algorithm*}[H]
		\SetFuncSty{textsc}
		\DontPrintSemicolon
		\SetKwData{Q}{Q}
		\SetKwData{L}{L}

		\SetKwFunction{relaxEdge}{relaxEdge}
		\SetKwFunction{queueDeleteMin}{deleteMin}

		\SetKwData{Q}{Q}
		\SetKwData{L}{L}
		\SetKwData{D}{D}
		\SetKwData{pred}{pred}
		\SetKwArray{ds}{ds}
		\SetKwFunction{queueDeleteMin}{deleteMin}
		\SetKwFunction{queueInsert}{insert}
		\SetKwFunction{queueMin}{min}
		\SetKwFunction{queueMinKey}{minKey}
		\SetKwFunction{queueDecreaseKey}{decreaseKey}
		\SetKwFunction{queueContains}{contains}
		\SetKwFunction{listInsert}{insert}
		\SetKwFunction{removeDom}{removeDominated}

		\SetKwProg{Pn}{Procedure}{:}{\KwRet}
		\Pn{\relaxEdge{(u,v), l}}{
			\If{$d_1(l) + \omega(u,v) < r_d$}
			{
				\D.\queueInsert{$(d_0(l) + \omega(u,v), d_1(l) + \omega(u,v), l)$}\;

				\If{$v \in P$}
				{
					\D.\queueInsert{$(d_0(l) + \omega(u,v) + d_p, 0, l)$}\;
				}

				\ForAll{ $l' \in D$ }
				{
					\If{$l'$ is not dominated by any label in \L{$v$}}
					{
						\L{$v$}.\removeDom{$l'$} \;
						\L{$v$}.\queueInsert{$l'$} \;
						\Q.\queueInsert{$l'$}
					}
				}
			}
		}
	\end{algorithm*}
	\setlength{\interspacetitleruled}{2pt}%
	\setlength{\algotitleheightrule}{\algotitleheightruledefault}%

	\caption{\label{alg:relax_edge}Relaxing an edge $(u,v) \in E$ when settling a label $l \in L(u)$ with regard to parking nodes.}
\end{figure}

\subsection{Initialization and Stopping Criterion}
We initialize the label set $L(s)$ of $s$ and the queue $Q$ with a label which only contains distances of zero and a dummy element as a predecessor. We stop the search when $t$ was removed from $Q$. The definition of the final algorithm \ref{alg:CSP} \textsc{Dijkstra+1-DTC} is now trivial.

\begin{algorithm}[bt]
	\caption{\textsc{Dijkstra+1-DTC}}\label{alg:CSP}

	% Some settings
	\DontPrintSemicolon %dontprintsemicolon
	\SetFuncSty{textsc}
	\SetKwFor{ForAll}{forall}{do}
	\SetKw{Return}{return}

	% Declaration of data containers and functions
	\SetKwData{Q}{Q}
	\SetKwData{dist}{d}
	\SetKwData{L}{L}
	\SetKwData{pred}{pred}
	\SetKwArray{ds}{ds}
	\SetKwFunction{queueDeleteMin}{deleteMin}
	\SetKwFunction{queueInsert}{insert}
	\SetKwFunction{queueMin}{min}
	\SetKwFunction{queueMinKey}{minKey}
	\SetKwFunction{queueDecreaseKey}{decreaseKey}
	\SetKwFunction{queueContains}{contains}
	\SetKwFunction{listInsert}{insert}
	\SetKwFunction{removeDom}{removeDominated}
	\SetKwFunction{settleNextNode}{settleNextNode}

	% Algorithm interface
	\KwIn{Graph $G=(V,E,\omega)$, set of parking nodes $P \subseteq V$, set of driving time constraints $R$, start and target nodes $s,t \in V$}
	\KwData{Priority queue \Q, per node set \L{$v$} of labels for all $v \in V$}
	\KwOut{Shortest travel time from $s$ to $t$ and corresponding $s$-$t$-path given by the predecessors of the label $l_t \in L(t)$}

	% The algorithm
	\BlankLine
	\tcp{Initialization}
	\Q.\queueInsert{$(0,0,\bot)$}\;
	\L{$s$}.\queueInsert{$(0,0,\bot)$}\;
	\BlankLine
	\tcp{Main loop}
	\While{\Q is not empty}
	{
		\settleNextNode{}\;

		\If{\text{minimum of $Q$ is label at $t$}}
		{
			\Return\;
		}
	}
\end{algorithm}

\subsection{Correctness}
TODO correctness stopping criterion

\section{A* with One Driving Time Constraint}
TODO dijkstra slow blabla therefore with ch potential just add potential everywhere

\begin{algorithm}[bt]
	\caption{\textsc{A*+1-DTC}}\label{alg:CSPPot}

	% Some settings
	\DontPrintSemicolon %dontprintsemicolon
	\SetFuncSty{textsc}
	\SetKwFor{ForAll}{forall}{do}
	\SetKw{Return}{return}

	% Declaration of data containers and functions
	\SetKwData{Q}{Q}
	\SetKwData{dist}{d}
	\SetKwData{L}{L}
	\SetKwData{pred}{pred}
	\SetKwArray{ds}{ds}
	\SetKwFunction{queueDeleteMin}{deleteMin}
	\SetKwFunction{queueInsert}{insert}
	\SetKwFunction{queueMin}{min}
	\SetKwFunction{queueMinKey}{minKey}
	\SetKwFunction{queueDecreaseKey}{decreaseKey}
	\SetKwFunction{queueContains}{contains}
	\SetKwFunction{listInsert}{insert}
	\SetKwFunction{removeDom}{removeDominated}
	\SetKwFunction{settleNextNode}{settleNextNode}

	% Algorithm interface
	\KwIn{Graph $G=(V,E,\omega)$, set of parking nodes $P \subseteq V$, set of driving time constraints $R$, start and target nodes $s,t \in V$, potential $pot()$}
	\KwData{Priority queue \Q, per node set \L{$v$} of labels for all $v \in V$}
	\KwOut{Shortest travel time from $s$ to $t$ and corresponding $s$-$t$-path given by the predecessors of the label $l_t \in L(t)$}

	% The algorithm
	\BlankLine
	\tcp{Initialization}
	\Q.\queueInsert{$pot((0,0,\bot))$}\;
	\L{$s$}.\queueInsert{$(0,0,\bot)$}\;
	\BlankLine
	\tcp{Main loop}
	\While{\Q is not empty}
	{
		\settleNextNode{}\;

		\If{\text{minimum of $Q$ is label at $t$}}
		{
			\Return\;
		}
	}
\end{algorithm}

TODO settlenextlabel is like in fig. \ref{alg:settle_next_label} but relax ege is now as in fig. \ref{alg:relax_edge_a_star}

\begin{figure}[hbtp]
	\setlength{\interspacetitleruled}{0pt}%
	\setlength{\algotitleheightrule}{0pt}%
	\begin{algorithm*}[H]
		\SetFuncSty{textsc}
		\DontPrintSemicolon
		\SetKwData{Q}{Q}
		\SetKwData{L}{L}

		\SetKwFunction{relaxEdge}{relaxEdge}
		\SetKwFunction{queueDeleteMin}{deleteMin}

		\SetKwData{Q}{Q}
		\SetKwData{L}{L}
		\SetKwData{D}{D}
		\SetKwData{pred}{pred}
		\SetKwArray{ds}{ds}
		\SetKwFunction{queueDeleteMin}{deleteMin}
		\SetKwFunction{queueInsert}{insert}
		\SetKwFunction{queueMin}{min}
		\SetKwFunction{queueMinKey}{minKey}
		\SetKwFunction{queueDecreaseKey}{decreaseKey}
		\SetKwFunction{queueContains}{contains}
		\SetKwFunction{listInsert}{insert}
		\SetKwFunction{removeDom}{removeDominated}

		\SetKwProg{Pn}{Procedure}{:}{\KwRet}
		\Pn{\relaxEdge{(u,v), l}}{
			\If{$d_1(l) + \omega(u,v) < r_d$}
			{
				\D.\queueInsert{$(d_0(l) + \omega(u,v), d_1(l) + \omega(u,v), l)$}\;

				\If{$v \in P$}
				{
					\D.\queueInsert{$(d_0(l) + \omega(u,v) + d_p, 0, l)$}\;
				}

				\ForAll{ $l' \in D$ }
				{
					\If{$l'$ is not dominated by any label in \L{$v$}}
					{
						\L{$v$}.\removeDom{$l'$} \;
						\L{$v$}.\queueInsert{$l'$} \;
						\Q.\queueInsert{$pot(l')$}
					}
				}
			}
		}
	\end{algorithm*}
	\setlength{\interspacetitleruled}{2pt}%
	\setlength{\algotitleheightrule}{\algotitleheightruledefault}%

	\caption{\label{alg:relax_edge_a_star} Relaxing an edge with regard to the potential.}
\end{figure}

\subsection{Potential for One Driving Time Constraint}\label{section:potential_csp}
Given a target node $t$, the CH potential $\pi_{t,ch}$ yields a perfect estimate for the distance $\drivingtime(v,t)$ from $v$ to $t$ without regard for driving time restrictions and pauses. A lower bound for the time $\traveltime(v,t)$ from $v$ to $t$ with breaks due to the driving time limit can be calculated by taking the minimum necessary amount of breaks on the shortest path into account:

\[\pi{'}_t(v) = \floor*{ \frac{\drivingtime(v,t)}{\restr_d} } * \restr_p + \drivingtime(v,t)\]

A node potential is called \emph{feasible} if it does not overestimate the distance of any edge in the graph, i.e.
\begin{align}
	\label{eq:node_potential_feasibility}
	len(u,v) - pot(u) + pot(v) \ge 0 \quad \forall (u,v) \in E
\end{align}
Following example of a query using the graph in Fig. \ref{fig:graph_infeasible_potential} shows that $\pi{'}_t$ is not feasible. With a driving time limit of 6 and a pause time of 1, the potential here will yield a value $\pi_t(s) = 8$ since the potential includes the minimum required pause time for a path from s to t. Consequently, with $\pi_t(v) = 5$ and $len(s,v) = 2$, $len(s,v) - \pi_t(s) + \pi_t(v) = -1$.

\begin{figure}[hbtp]
	\centering
	\input{figures/graph_infeasible_potential.tex}
	\caption{A graph with the potential to break the potential.}
	\label{fig:graph_infeasible_potential}
\end{figure}

A variant of the potential accounts for the distance $\traveltime(p,v)$ with $p$ being the last parking node that was used for a pause to calculate the minimum required pause time on the $v$-$t$ path. Since the potential now uses information from a label $l$ with $l \in L(v)$, it no longer is a node potential but also depends on the chosen label at $v$.

\begin{align*}
	\pi_t(l,v) & = \floor*{ \frac{\drivingtime(p,v) + \drivingtime(v,t)}{\restr_d} } * \restr_p + \drivingtime(v,t) \\
	           & = \floor*{ \frac{d_1(l) + \drivingtime(v,t)}{\restr_d} } * \restr_p + \drivingtime(v,t)
\end{align*}

Since the potential $\pi_t$ now uses label information it no longer is a node potential and the feasibility definition as defined in inequality \ref{eq:node_potential_feasibility} can no longer be applied. We still want to use potential and label information to calculate lower bound estimates for the length of paths.

\begin{lemma}\label{lemma:pot_labels_get_larger}
	Let $p = \langle s=v_0,v_1,...,t=v_k, \rangle$ be a path with labels $l_i$ at nodes $v_i$. Then $d_0(l_{i-1}) + \pi_t(l_{i-1},v_{i-1}) \le d_0(l_i) + \pi_t(l_i,v_i)$.
\end{lemma}

The lower bound estimate for the length of the entire path to which a label belongs can only increase when propagating labels to a next node.

\begin{proof}
	Given a Graph $G=(V,E)$ with a set of parking nodes $P \subseteq V$, let $p = \langle s=v_0,v_1,...,t=v_k, \rangle$ be a path in G with labels $l_i$ at nodes $v_i$. Let $p,q \in P \cup \{s\}$ the last parking node which was used by label $l_{i-1}$ and $l_{i}$ or $s$, if no parking node was used.

	\begin{align}
		\begin{split}\label{eq:label_feasibility_proof_1}
			d_0(l_{i-1}) + \pi_t(l_{i-1},v_{i-1}) &= d_0(l_{i-1})+\floor*{ \frac{d_1(l_{i-1}) + \drivingtime(v_{i-1},t)}{\restr_d} } * \restr_p + \drivingtime(v_{i-1},t)\\
			&= d_0(l_{i-1})+ \floor*{ \frac{\drivingtime(p,v_{i-1}) + \drivingtime(v_{i-1},t)}{\restr_d} } * \restr_p + \drivingtime(v_{i-1},t)\\
			&=\traveltime(s,p) + \drivingtime(p,v_{i-1})\\
			& \phantom{{}=1} + \underbrace{\floor*{ \frac{\drivingtime(p,v_{i-1}) + \drivingtime(v_{i-1},t)}{\restr_d} } * \restr_p}_\text{minimum required pause time on p-t subpath} + \drivingtime(v_{i-1},t)
		\end{split}
	\end{align}

	\emph{Case 1: $p=q$}

	\begin{align}
		\begin{split}\label{eq:label_feasibility_proof_2}
			\drivingtime(p,v_{i-1}) + \drivingtime(v_{i-1},t) & = \drivingtime(p,v_{i-1}) + len(v_{i-1},v_i) + \drivingtime(v_i,t) \\
			& = \drivingtime(q,v_{i-1}) + len(v_{i-1},v_i) + \drivingtime(v_i,t) \\
			& = \drivingtime(q,v_i) + \drivingtime(v_i,t)
		\end{split}
	\end{align}

	With equations \ref{eq:label_feasibility_proof_1} follows

	\begin{align}
		\begin{split}\label{eq:label_feasibility_proof_3}
			d_0(l_{i-1}) + \pi_t(l_{i-1},v_{i-1}) &= \traveltime(s,p) + \drivingtime(p,v_{i-1}) + \drivingtime(v_{i-1},t)\\
			& \phantom{{}=1} + \floor*{ \frac{\drivingtime(p,v_{i-1}) + \drivingtime(v_{i-1},t)}{\restr_d} } * \restr_p\\
			&= \traveltime(s,q) + \drivingtime(q,v_{i}) + \drivingtime(v_{i},t)\\
			& \phantom{{}=1} + \floor*{ \frac{\drivingtime(q,v_{i1}) + \drivingtime(v_{i},t)}{\restr_d} } * \restr_p\\
			&= d_0(l_{i}) + \pi_t(l_{i},v_{i})
		\end{split}
	\end{align}

	\emph{Case 2: $p \neq q$}. In this case, $q = v_i$ and $\traveltime(p,v_i) = \traveltime(p,q) = \drivingtime(p,v_i) + \restr_p = $. With \ref{eq:label_feasibility_proof_1} follows

	\begin{align}
		\begin{split}\label{eq:label_feasibility_proof_4}
			d_0(l_{i-1}) + \pi_t(l_{i-1},v_{i-1}) &= \traveltime(s,p) + \drivingtime(p,v_{i-1}) + \drivingtime(v_{i-1},t)\\
			& \phantom{{}=1} + \floor*{ \frac{\drivingtime(p,v_{i-1}) + \drivingtime(v_{i-1},t)}{\restr_d} } * \restr_p\\
			&= \traveltime(s,p) + \drivingtime(p,v_{i}) + \drivingtime(v_{i},t)\\
			& \phantom{{}=1} + \floor*{ \frac{\drivingtime(p,v_{i}) + \drivingtime(v_{i},t)}{\restr_d} } * \restr_p\\
			&\le \traveltime(s,p) + \traveltime(p,q) - \restr_p + \drivingtime(v_{i},t)\\
			& \phantom{{}=1} + \floor*{ \frac{\drivingtime(v_{i},t)}{\restr_d} } * \restr_p + \restr_p\\
			&= \traveltime(s,q) + 0 + \drivingtime(v_{i},t)\\
			& \phantom{{}=1} + \floor*{ \frac{0 + \drivingtime(v_{i},t)}{\restr_d} } * \restr_p\\
			&= \traveltime(s,q) + \drivingtime(q,v_{i}) + \drivingtime(v_{i},t)\\
			& \phantom{{}=1} + \floor*{ \frac{\drivingtime(q,v_{i}) + \drivingtime(v_{i},t)}{\restr_d} } * \restr_p\\
			&= d_0(l_{i}) + \pi_t(l_{i1},v_{i})
		\end{split}
	\end{align}
\end{proof}

\begin{lemma}\label{lemma:pot_lower_bound_csp}
	The potential $\pi_t(l,v)$ of a label $l$ at a node $v$ is a lower bound for the distance including pauses from $v$ to $t$.
\end{lemma}

\begin{proof}
	Let $p = \langle s=v_0,v_1,...,t=v_k, \rangle$ be a path with labels $l_i$ at nodes $v_i$. With $d_0(l_{i-1}) + \pi_t(l_{i-1},v_{i-1}) \ge d_0(l_{i}) + \pi_t(l_i,v_i)$ for all edges on $p$, the total length $len(p)$ of the path must follow $\pi_t(l_i,v_i) \le len(p) + \pi_t(l_k,t) \Leftrightarrow l(p) \ge \pi_t(l_i,v_i) - \pi_t(l_k,t)$. Since $\pi_t(l_k,t) = 0$, $l(p) \ge \pi_t(l_i,v_i)$ holds.
\end{proof}

\begin{theorem}\label{theorem:pot_stop_criterion}
	The search can be stopped when the first label at $t$ is removed from the queue.
\end{theorem}

\begin{proof}
	When a label $l$ at $t$ is removed from the queue during a $s$-$t$ query, all remaining label $m$ of a node $v$ in the queue fulfill $d_0(t) + \pi_t(l,t) \le d_0(v) + \pi_t(m,v)$. Assume that $d_0(t)$ is not the shortest distance from $s$ to $t$. Then, a shorter path $p = \langle s=v_0,v_1,...,t=v_k, \rangle$ exists which uses at least one unsettled label $m \in L(v_i)$. Since $l$ was already removed from the queue, $d_0(t) = d_0(t) + \pi_t(l,t) \le  d_0(v) + \pi_t(m,v) \le l(p)$ which contradicts the assumption that $p$ yields a shorter $s$-$t$ distance than $d_0(t)$.
\end{proof}

\section{Multiple Driving Time Constraints}
Dijkstra's algorithm with one driving time constraint (1-DTC) can easily be adapted to handle multiple driving time constraints $r_i$. We abbreviate the generalized problem \emph{n-DTC}. For a number of $n$ driving time constraints, a label now contains the total travel time $d_0$ and $n$ driving time values $d_1, ... , d_n$. Each $d_i$ represents the driving time since the last pause at a node $v$ with pause time $\rho(v) \ge r_{i,p}$. Pausing at a node occurs with one of the available pause times $r_{i,p}$ of a driving time restriction $r_i \in R$. Pausing with an arbitrary pause time is possible but yields longer travel times and no advantage. When a path pauses at $v$ for a time $r_{i,p}$, the corresponding label $l \in L(v)$ has $d_j(l) = 0$ for all $0 < j \le i$ since the pauses with shorter pause times are \emph{included} in the longer pause.

\paragraph{Label Propagation.}
Label propagation simply extends the component-wise addition of the edge weight to all elements of the distance vector. Let $l \in L(u)$ be a label at $u$ and $(u,v) = e \in E$, then $l$ can be propagated to $v$ resulting in a label $l'$ with $d_i(l') = d_i(l) + \omega(e)$ $\forall i \le |R|$, and $\pred(l') = l$.

\paragraph{Label Pruning.}
The pruning rule for driving time constraints generalizes is a similar way. A label is discarded if $d_i(l) \ge r_{d,i}$ for any $i$ with $0 < i \le |R|$.


\paragraph{Label Dominance}
At last, label dominance can be generalized to multiple driving time constraints as follows.
\begin{definition}[Label Dominance]
	A label $l \in L(v)$ dominates another label $m \in L(v)$ if $d_i(m) \ge d_i(l)$ $\forall i \le |R|$.
\end{definition}

\section{Potential for Multiple Driving Time Constraints}
In section \ref{section:potential_csp} we defined the potential $\pi_t(l,v)$ to extend Dijkstra to an A* search with one driving time constraint. We will now generalize $\pi_t$ for the use with an arbitrary number $n$ of driving time constraints.

To calculate $\pi_t(l,v)$, we used the distance without regard for pausing from $v$ to $t$ and the distance $d_1(l)$ to calculate a lower bound for the amount of necessary pauses until we reach the target node. With one driving time restriction it is

\[\textit{minimum number of pauses} = \floor*{ \frac{d_{1}(l) + \drivingtime(v,t)}{t_{d,i}} }.\]

We now have to calculate the lower bound with respect to the different driving time constraints. How many pauses of which duration do we need at least to comply with all driving time restrictions $r_i$? We need a smaller or equal amount of pauses for longer driving time restrictions since they have a longer maximum allowed driving time $r_{d,i}$. At the same time, a pause of length $r_{p,i}$ will also include a pause of lengths $r_{p,j}$ with $j < i$. We therefore start with calculating the amount of necessary pauses of the longest restriction $r_n$. Then, we calculate how many pauses we need at least for the next smaller constraint and subtract the amount of pauses we just calculated for $r_n$. We repeat this process for each remaining driving time restriction and accumulate the product of number of pauses for $r_i$ and its corresponding pause time $r_{p,i}$ to yield the minimum total pause time on the remaining path to $t$. Finally, we add the raw driving time $\drivingtime{v,t}$. We now can define $\pi_t$ as

\begin{align*}
	\pi_t(v,l) = \drivingtime(v,t) + \sum_{i=1}^n{ n_i * t_{p,i}}
\end{align*}

with

\begin{align*}
	n_i =\begin{dcases}
		\floor*{ \frac{d_{i}(l) + \drivingtime(v,t)}{t_{i,d}} } - \floor*{ \frac{d_{i+1}(l) + \drivingtime(v,t)}{t_{d,i+1}} } & 0 < i < n \\
		\floor*{ \frac{d_{i}(l) + \drivingtime(v,t)}{\restr_d} }                                                              & i=n
	\end{dcases}
\end{align*}

The value of $n_i$ for $0 < i < n$ can also be calculated by reusing already computed values $n_j$ with $j > i$:

\begin{align*}
	n_i =\begin{dcases}
		\floor*{ \frac{d_{i}(l) + \drivingtime(v,t)}{t_{i,d}} } - \sum_{j=i+1}^{n}{n_{j} } & 0 < i < n \\
		\floor*{ \frac{d_{i}(l) + \drivingtime(v,t)}{\restr_d} }                           & i=n
	\end{dcases}
\end{align*}

If lemma \ref{lemma:pot_labels_get_larger} still holds then, lemma \ref{lemma:pot_lower_bound_csp} and theorem \ref{theorem:pot_stop_criterion} follow as a consequence.

\begin{lemma}
	Lemma \ref{lemma:pot_labels_get_larger} still holds for an arbitrary number $n$ of driving time constraints.
\end{lemma}

\begin{proof}
	Given a Graph $G=(V,E)$ with a set of parking nodes $P \subseteq V$, let $p = \langle s=v_0,v_1,...,t=v_k, \rangle$ be a path in G with labels $l_i$ at nodes $v_i$. Let $p,q \in P \cup \{s\}$ the last parking node which was used by label $l_{i-1}$ and $l_{i}$ or $s$, if no parking node was used. Let

	\begin{align}
		\begin{split}\label{eq:label_n_feasibility_proof_1}
			d_0(l_{i-1}) + \pi_t(l_{i-1},v_{i-1}) &= d_0(l_{i-1})+\floor*{ \frac{d_1(l_{i-1}) + \drivingtime(v_{i-1},t)}{\restr_d} } * \restr_p + \drivingtime(v_{i-1},t)\\
			&= d_0(l_{i-1})+ \floor*{ \frac{\drivingtime(p,v_{i-1}) + \drivingtime(v_{i-1},t)}{\restr_d} } * \restr_p + \drivingtime(v_{i-1},t)\\
			&=\traveltime(s,p) + \drivingtime(p,v_{i-1})\\
			& \phantom{{}=1} + \underbrace{\floor*{ \frac{\drivingtime(p,v_{i-1}) + \drivingtime(v_{i-1},t)}{\restr_d} } * \restr_p}_\text{minimum required pause time on p-t subpath} + \drivingtime(v_{i-1},t)
		\end{split}
	\end{align}

	\emph{Case 1: $p=q$}

	\begin{align}
		\begin{split}\label{eq:label_n_feasibility_proof_2}
			\drivingtime(p,v_{i-1}) + \drivingtime(v_{i-1},t) & = \drivingtime(p,v_{i-1}) + len(v_{i-1},v_i) + \drivingtime(v_i,t) \\
			& = \drivingtime(q,v_{i-1}) + len(v_{i-1},v_i) + \drivingtime(v_i,t) \\
			& = \drivingtime(q,v_i) + \drivingtime(v_i,t)
		\end{split}
	\end{align}

	With equations \ref{eq:label_n_feasibility_proof_1} follows

	\begin{align}
		\begin{split}\label{eq:label_n_feasibility_proof_3}
			d_0(l_{i-1}) + \pi_t(l_{i-1},v_{i-1}) &= \traveltime(s,p) + \drivingtime(p,v_{i-1}) + \drivingtime(v_{i-1},t)\\
			& \phantom{{}=1} + \floor*{ \frac{\drivingtime(p,v_{i-1}) + \drivingtime(v_{i-1},t)}{\restr_d} } * \restr_p\\
			&= \traveltime(s,q) + \drivingtime(q,v_{i}) + \drivingtime(v_{i},t)\\
			& \phantom{{}=1} + \floor*{ \frac{\drivingtime(q,v_{i1}) + \drivingtime(v_{i},t)}{\restr_d} } * \restr_p\\
			&= d_0(l_{i}) + \pi_t(l_{i},v_{i})
		\end{split}
	\end{align}

	\emph{Case 2: $p \neq q$}. In this case, $q = v_i$ and $\traveltime(p,v_i) = \traveltime(p,q) = \drivingtime(p,v_i) + \restr_p = $. With \ref{eq:label_n_feasibility_proof_1} follows

	\begin{align}
		\begin{split}\label{eq:label_n_feasibility_proof_4}
			d_0(l_{i-1}) + \pi_t(l_{i-1},v_{i-1}) &= \traveltime(s,p) + \drivingtime(p,v_{i-1}) + \drivingtime(v_{i-1},t)\\
			& \phantom{{}=1} + \floor*{ \frac{\drivingtime(p,v_{i-1}) + \drivingtime(v_{i-1},t)}{\restr_d} } * \restr_p\\
			&= \traveltime(s,p) + \drivingtime(p,v_{i}) + \drivingtime(v_{i},t)\\
			& \phantom{{}=1} + \floor*{ \frac{\drivingtime(p,v_{i}) + \drivingtime(v_{i},t)}{\restr_d} } * \restr_p\\
			&\le \traveltime(s,p) + \traveltime(p,q) - \restr_p + \drivingtime(v_{i},t)\\
			& \phantom{{}=1} + \floor*{ \frac{\drivingtime(v_{i},t)}{\restr_d} } * \restr_p + \restr_p\\
			&= \traveltime(s,q) + 0 + \drivingtime(v_{i},t)\\
			& \phantom{{}=1} + \floor*{ \frac{0 + \drivingtime(v_{i},t)}{\restr_d} } * \restr_p\\
			&= \traveltime(s,q) + \drivingtime(q,v_{i}) + \drivingtime(v_{i},t)\\
			& \phantom{{}=1} + \floor*{ \frac{\drivingtime(q,v_{i}) + \drivingtime(v_{i},t)}{\restr_d} } * \restr_p\\
			&= d_0(l_{i}) + \pi_t(l_{i1},v_{i})
		\end{split}
	\end{align}
\end{proof}


\section{Core Contraction Hierarchy Variant}
\begin{algorithm}[hbtp]
	\caption{\textsc{Core-CH with Driving Time Constraints}}\label{alg:CSPCoreCH}

	% Some settings
	\DontPrintSemicolon %dontprintsemicolon
	\SetFuncSty{textsc}
	\SetKwFor{ForAll}{forall}{do}

	% Declaration of data containers and functions
	\SetKwData{Q}{Q}
	\SetKwData{L}{L}
	\SetKwData{pot}{pot}
	\SetKwFunction{queueDeleteMin}{deleteMin}
	\SetKwFunction{queueInsert}{insert}
	\SetKwFunction{queueMin}{min}
	\SetKwFunction{queueMinKey}{minKey}
	\SetKwFunction{queueDecreaseKey}{decreaseKey}
	\SetKwFunction{queueContains}{contains}
	\SetKwFunction{listInsert}{insert}
	\SetKwFunction{removeDom}{removeDominated}

	% Algorithm interface
	\KwIn{Graph $G = (V,E,\omega)$, parking nodes $P \subseteq V$, driving time restriction $r$, potential \pot{}, source node $s \in V$}
	\KwData{Priority queue \Q, per node priority queue \L{$v$} of labels for all $v \in V$}
	\KwOut{Distances for all $v \in V$, tree of allowed shortest paths according to the restriction $r$ from $s$, given by $l_{pred}$}

	% The algorithm
	\BlankLine
	\tcp{Initialization}
	\Q.\queueInsert{$s,(0,0)$}\;
	\L{$s$}.\queueInsert{$(\bot,\bot),\pot{(0,0)}$}\;
	\BlankLine
	\tcp{Main loop}
	\While{\Q is not empty}
	{
		$u \leftarrow$ \Q.\queueDeleteMin{} \;
		$(d_0, d_1) \leftarrow$ \L{$u$}.\queueMinKey{} \;
		$l \leftarrow$ \L{$u$}.\queueDeleteMin{} \;
		\BlankLine
		\If{\L{$u$} is not empty}
		{
			$k_{dist} \leftarrow$ \L{$u$}.\queueMinKey{} \;
			\Q.\queueInsert{$u$, $k_{dist}$} \;
		}

		\ForAll{ $(u,v) \in E$ }
		{
			\If{$d_0 + \omega(u,v) < r_d$}
			{
				$D \leftarrow \{(d_0 + \omega(u,v), d_1 + \omega(u,v))\}$

				\If{$v \in P$}
				{
					$D$.\listInsert{$(d_0 + \omega(u,v) + r_p, 0)$}
				}

				\ForAll{ $x \in D$ }
				{
					\If{$x$ is not dominated by any label in \L{$v$}}
					{
						\L{$v$}.\removeDom{$x$} \;
						\L{$v$}.\queueInsert{$(l,(u,v)), x$} \;
						\uIf{\Q.\queueContains{v}}
						{
							\Q.\queueDecreaseKey{$v, x$}
						}
						\Else
						{
							\Q.\queueInsert{$v, x$}
						}
					}
				}
			}
		}
	}
\end{algorithm}
\subsection{Building the Contraction Hierarchy}

\section{Combining A* and Core Contraction Hierarchy}