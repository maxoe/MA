%% content.tex
%%

%% ==============
\chapter{Algorithm}
\label{ch:Algorithm}
%% ==============
In this chapter, we introduce a labeling algorithm which solves the long-haul truck driver routing problem. We then describe extensions of the base algorithm to achieve better runtimes on road networks in practice. At first, we will restrict the problem to one driving time constraint for simplicity and drop that constraint later.

\section{Dijkstra's Algorithm with One Driving Time Constraint\label{sec:dijkstra_csp}}
Dijkstra's algorithm solves the shortest path problem by maintaining a queue $Q$ of nodes with ascending tentative distance from the starting node $s$, and iteratively settling the node with the smallest distance. When Dijkstra settles a node $u$, it tests if the distance to the neighbor nodes $v$ with $(u,v) \in E$ can be improved by choosing the current node as a predecessor. We say it \emph{relaxes} all edges $(u,v) \in E$. The search can be stopped if the target node $t$ was removed from the queue \cite{dijkstra:1959}.

We will adapt Dijkstra's algorithm for solving the long-haul truck driver routing problem with one driving time constraint $r$ and abbreviate this restriction of the problem \emph{1-DTC}. While Dijkstra's algorithm manages a queue of nodes and assigns each node one tentative distance, our algorithm manages a queue $Q$ of labels and a set $L(v)$ of labels for each node $v \in V$.

Labels represent a possible journey, respectively a possible solution for a query from $s$ to the node they belong to. A label in a label set $L(v)$ may represent suboptimal journeys to $v$, i.e., journeys which are not a shortest journey between $s$ and $v$. A label set never contains label which represent journeys with an invalid path according to $r$. A label $l$ contains

\begin{itemize}
	\item $\concretett(l)$, the total travel time from the starting node $s$
	\item $\breakDist(l)$, the driving time since the last break
	\item $\pred(l)$, its preceding label
\end{itemize}

\subsection{Settling a Label}
In contrast to Dijkstra, the search \emph{settles} a label $l \in L(u)$ in each iteration instead of a node $u$. When settling a label, the search first removes $l$ from the queue. Similar to Dijkstra, it then relaxes all edges $(u,v) \in E$ with $l \in L(u)$ as shown in fig. \ref{alg:settle_next_label}.

\begin{figure}[hbtp]
	\setlength{\interspacetitleruled}{0pt}%
	\setlength{\algotitleheightrule}{0pt}%
	\begin{algorithm*}[H]
		\SetFuncSty{textsc}
		\DontPrintSemicolon
		\SetKwData{Q}{Q}
		\SetKwData{L}{L}

		\SetKwFunction{settleNextLabel}{settleNextLabel}
		\SetKwFunction{relaxEdge}{relaxEdge}
		\SetKwFunction{queueDeleteMin}{deleteMin}

		\SetKwProg{Pn}{Procedure}{:}{\KwRet}
		\Pn{\settleNextLabel{}}{
			$l \leftarrow$ \Q.\queueDeleteMin{} \;
			\BlankLine

			\ForAll{ $(u,v) \in E$ }
			{
				\relaxEdge{$(u,v),l$}
			}
		}
	\end{algorithm*}
	\setlength{\interspacetitleruled}{2pt}%
	\setlength{\algotitleheightrule}{\algotitleheightruledefault}%

	\caption{\label{alg:settle_next_label}Settling a label $l \in L(u)$ removes the label from the queue and relaxes all the outgoing edges of $u$.}
\end{figure}

Relaxing an edge consists of the three steps label \emph{propagation}, \emph{pruning} and \emph{dominance} checks.

\paragraph{Label Propagation.}
Labels can be propagated along edges. Let $l \in L(u)$ be a label at $u$ and $(u,v) = e \in E$, then $l$ can be propagated to $v$ resulting in a label $l'$ with $\concretett(l') = \concretett(l) + \mathfunction{len}(e)$, $\breakDist(l') = \breakDist(l) + \mathfunction{len}(e)$, and $\pred(l') = l$.

\paragraph{Label Pruning.}
After propagating a label, we discard the label if it violates the driving time constraint $r$. That is, if $\breakDist(l) > \restr_d$.


\paragraph{Label Dominance}
In general, it is no longer clear when a label presents a better solution than another label since it now contains two distance values. A label $l$ at a node $v$ might represent a shorter journey from $s$ to $v$ than another label $m$ but might have shorter remaining driving time budget $\restr_d - \breakDist(l)$. The label $l$ yields a better solution for a query $s$-$v$, but this does not imply that it is part of a better solution for a query from $s$ to $t$. It might not even yield a valid path to $t$ at all while $m$ reaches the target due to the greater remaining driving time budget. In one case we can proof that a label $l \in L(v)$ cannot yield a better solution than a label $m \in L(v)$. We say $m$ \emph{dominates} $l$.

\begin{definition}[Label Dominance for 1-DTC]
	A label $l \in L(v)$ dominates another label $m \in L(v)$ if $\concretett(m) \ge \concretett(l)$ and $\breakDist(m) \ge \breakDist(l)$.
\end{definition}

If a label $l \in L(v)$ is dominated by another label $m \in L(v)$, then $m$ represents a journey from $s$ to $t$ with a shorter or equal total travel time and longer remaining driving time budget until the next break. Therefore, in each solution which uses the label $l$, $l$ can trivially be replaced by the label $m$. The solution will still comply with the driving time constraint $r$ and yield a shorter or equal total travel time, so we are allowed to simply discard dominated labels in our search.

\begin{definition}[Pareto-Optimal Label]
	A label $l \in L(v)$ is pareto-optimal if it is not dominated by any other label $m \in L(v)$.
\end{definition}

We will only add a label $l$ to a label set $L(v)$ if it is pareto-optimal. Labels $m \in L(v)$ are then removed from $L(v)$ if $l$ dominates them. $L(v)$ therefore is the set of pareto-optimal solutions at $v$. In fig. \ref{alg:remove_dominated} we define the procedure \textsc{removeDominated($l$)} as a label set operation.

\begin{figure}[hbtp]
	\setlength{\interspacetitleruled}{0pt}%
	\setlength{\algotitleheightrule}{0pt}%
	\begin{algorithm*}[H]
		\SetFuncSty{textsc}
		\SetKwFor{ForAll}{forall}{do}
		\DontPrintSemicolon
		\SetKwData{L}{L}

		\SetKwFunction{removeDominated}{removeDominated}
		\SetKwFunction{queueRemove}{remove}

		\SetKwProg{Pn}{Procedure}{:}{\KwRet}
		\Pn{\removeDominated{$l$}}{
			\ForAll{$m \in L$}
			{
				\If{\text{$l$ dominates $m$}}{
					\L.\queueRemove($m$)\;
				}
			}
		}
	\end{algorithm*}
	\setlength{\interspacetitleruled}{2pt}%
	\setlength{\algotitleheightrule}{\algotitleheightruledefault}%

	\caption{\label{alg:remove_dominated}The operation which is defined on a label set $L$, removes all labels from the set which are dominated by the label $l$.}
\end{figure}

We now use \textsc{removeDominated} to define the procedure \textsc{relaxEdge$'$} as described in fig. \ref{alg:relax_edge_no_p} which propagates a label along an edge and updates the neighbor node's label set if necessary.

\begin{figure}[hbtp]
	\setlength{\interspacetitleruled}{0pt}%
	\setlength{\algotitleheightrule}{0pt}%
	\begin{algorithm*}[H]
		\SetFuncSty{textsc}
		\DontPrintSemicolon
		\SetKwData{Q}{Q}
		\SetKwData{L}{L}

		\SetKwFunction{relaxEdgeNoP}{relaxEdge$'$}
		\SetKwFunction{queueDeleteMin}{deleteMin}

		\SetKwData{Q}{Q}
		\SetKwData{dist}{d}
		\SetKwData{L}{L}
		\SetKwData{pred}{pred}
		\SetKwArray{ds}{ds}
		\SetKwFunction{queueDeleteMin}{deleteMin}
		\SetKwFunction{queueInsert}{queueInsert}
		\SetKwFunction{setInsert}{insert}
		\SetKwFunction{queueMin}{min}
		\SetKwFunction{queueMinKey}{minKey}
		\SetKwFunction{queueDecreaseKey}{decreaseKey}
		\SetKwFunction{queueContains}{contains}
		\SetKwFunction{listInsert}{insert}
		\SetKwFunction{removeDom}{removeDominated}

		\SetKwProg{Pn}{Procedure}{:}{\KwRet}
		\Pn{\relaxEdgeNoP{(u,v), l}}{
			\If{$\breakDist(l) + \mathfunction{len}(u,v) < \restr_d$}
			{
				$l' \leftarrow \{(\concretett(l) + \mathfunction{len}(u,v), \breakDist(l) + \mathfunction{len}(u,v)), l\}$\;
				\If{$l'$ is not dominated by any label in \L{$v$}}
				{
					\L{$v$}.\removeDom{$l'$} \;
					\L{$v$}.\setInsert{$l'$} \;
					\Q.\queueInsert{$\concretett(l')$, $l'$}
				}
			}
		}
	\end{algorithm*}
	\setlength{\interspacetitleruled}{2pt}%
	\setlength{\algotitleheightrule}{\algotitleheightruledefault}%

	\caption{\label{alg:relax_edge_no_p}Relaxing an edge $(u,v) \in E$ when settling a label $l \in L(u)$.}
\end{figure}

\subsection{Parking at a Node}
The procedure \textsc{relaxEdge$'$} does not account for parking nodes. When propagating a label $l \in L(u)$ along an edge $(u,v) \in E$ and $v \in P$ then we have to consider pausing at $v$. Since we do not know if pausing at $v$ or continuing without a break is the better solution, we generate both labels and them to label set $L(v)$ and the queue $Q$ as defined in fig. \ref{alg:relax_edge}.

\begin{figure}[hbtp]
	\setlength{\interspacetitleruled}{0pt}%
	\setlength{\algotitleheightrule}{0pt}%
	\begin{algorithm*}[H]
		\SetFuncSty{textsc}
		\DontPrintSemicolon
		\SetKwData{Q}{Q}
		\SetKwData{L}{L}

		\SetKwFunction{relaxEdge}{relaxEdge}
		\SetKwFunction{queueDeleteMin}{deleteMin}

		\SetKwData{Q}{Q}
		\SetKwData{L}{L}
		\SetKwData{D}{D}
		\SetKwData{pred}{pred}
		\SetKwArray{ds}{ds}
		\SetKwFunction{queueDeleteMin}{deleteMin}
		\SetKwFunction{queueInsert}{queueInsert}
		\SetKwFunction{setInsert}{insert}
		\SetKwFunction{queueMin}{min}
		\SetKwFunction{queueMinKey}{minKey}
		\SetKwFunction{queueDecreaseKey}{decreaseKey}
		\SetKwFunction{queueContains}{contains}
		\SetKwFunction{listInsert}{insert}
		\SetKwFunction{removeDom}{removeDominated}

		\SetKwProg{Pn}{Procedure}{:}{\KwRet}
		\Pn{\relaxEdge{(u,v), l}}{
			$\D \leftarrow \{\}$\;
			\If{$\breakDist(l) + \mathfunction{len}(u,v) < \restr_d$}
			{
				\D.\setInsert{$(\concretett(l) + \mathfunction{len}(u,v), \breakDist(l) + \mathfunction{len}(u,v), l)$}\;

				\If{$v \in P$}
				{
					\D.\setInsert{$(\concretett(l) + \mathfunction{len}(u,v) + \restr_b, 0, l)$}\;
				}

				\ForAll{ $l' \in D$ }
				{
					\If{$l'$ is not dominated by any label in \L{$v$}}
					{
						\L{$v$}.\removeDom{$l'$} \;
						\L{$v$}.\setInsert{$l'$} \;
						\Q.\queueInsert{$\concretett(l')$,$l'$}
					}
				}
			}
		}
	\end{algorithm*}
	\setlength{\interspacetitleruled}{2pt}%
	\setlength{\algotitleheightrule}{\algotitleheightruledefault}%

	\caption{\label{alg:relax_edge}Relaxing an edge $(u,v) \in E$ when settling a label $l \in L(u)$ with regard to parking nodes.}
\end{figure}

\subsection{Initialization and Stopping Criterion}
We initialize the label set $L(s)$ of $s$ and the queue $Q$ with a label which only contains distances of zero and a dummy element as a predecessor. We stop the search when $t$ was removed from $Q$. The definition of the final algorithm \ref{alg:CSP} \textsc{Dijkstra+1-DTC} is now trivial.

\begin{algorithm}[bt]
	\caption{\textsc{Dijkstra+1-DTC}}\label{alg:CSP}

	% Some settings
	\DontPrintSemicolon %dontprintsemicolon
	\SetFuncSty{textsc}
	\SetKwFor{ForAll}{forall}{do}

	% Declaration of data containers and functions
	\SetKwData{Q}{Q}
	\SetKwData{dist}{d}
	\SetKwData{L}{L}
	\SetKwData{pred}{pred}
	\SetKwArray{ds}{ds}
	\SetKwFunction{queueDeleteMin}{deleteMin}
	\SetKwFunction{queueInsert}{queueInsert}
	\SetKwFunction{setInsert}{insert}
	\SetKwFunction{queueMin}{min}
	\SetKwFunction{queueMinKey}{minKey}
	\SetKwFunction{queueDecreaseKey}{decreaseKey}
	\SetKwFunction{queueContains}{contains}
	\SetKwFunction{listInsert}{insert}
	\SetKwFunction{removeDom}{removeDominated}
	\SetKwFunction{settleNextNode}{settleNextNode}

	% Algorithm interface
	\KwIn{Graph $G=(V,E,\mathfunction{len})$, set of parking nodes $P \subseteq V$, set of driving time constraints $R=\{r\}$, start and target nodes $s,t \in V$}
	\KwData{Priority queue \Q, per node set \L{$v$} of labels for all $v \in V$}
	\KwOut{Shortest journey with $\concretett(j) = \traveltime(s,t)$}

	% The algorithm
	\BlankLine
	\tcp{Initialization}
	\Q.\queueInsert{$0$,$(0,0,\bot)$}\;
	\L{$s$}.\setInsert{$(0,0,\bot)$}\;
	\BlankLine
	\tcp{Main loop}
	\While{\Q is not empty}
	{
		\settleNextNode{}\;

		\If{\text{minimum of $Q$ is label at $t$}}
		{
			\Return\;
		}
	}
\end{algorithm}

\subsection{Correctness\label{sec:dijkstra_csp_correctness}}
An $s$-$t$ query with the original Dijkstra's algorithm can be stopped when $t$ was removed from the queue since all of the following nodes in the queue have larger distances and because edge lengths are nonnegative by definition. Therefore, relaxing any edge of those nodes cannot lead to an improvement of the distance at $t$.
In our case, the labels in the queue are ordered by their travel time. Relaxing an edge can only increase the travel time since both, edge lengths and break times are nonnegative. Therefore, the same argument as for the original Dijkstra's algorithm applies and the first label at $t$ which was removed from the queue contains the shortest travel time $\traveltime(s,t)$.

\section{A* with One Driving Time Constraint}
In this section, we transform the base algorithm described in section \ref{sec:dijkstra_csp} to a goal-directed A* search. We introduce a new potential $\concretepotential_t$ which is based on the CH potential described in section \ref{sec:ch_pot}. We then show that we still can stop the search when the first label at $t$ is removed from the queue.

The difference between Dijkstra and A* is the order in which nodes are being removed from the queue. In our case, this corresponds to labels being removed from the queue. Instead of using their travel time $\concretett(l)$ as a queue key, a label $l \in L(v)$ is added to the queue with key $\concretett(l) + \concretepotential_t(l,v)$. As shown in algorithm \ref{alg:CSPPot}, the adaption of the pseudocode of the coarse algorithm is trivial.

\begin{algorithm}[bt]
	\caption{\textsc{A*+1-DTC}}\label{alg:CSPPot}

	% Some settings
	\DontPrintSemicolon %dontprintsemicolon
	\SetFuncSty{textsc}
	\SetKwFor{ForAll}{forall}{do}

	% Declaration of data containers and functions
	\SetKwData{Q}{Q}
	\SetKwData{dist}{d}
	\SetKwData{L}{L}
	\SetKwData{pred}{pred}
	\SetKwArray{ds}{ds}
	\SetKwFunction{queueDeleteMin}{deleteMin}
	\SetKwFunction{queueInsert}{queueInsert}
	\SetKwFunction{setInsert}{insert}
	\SetKwFunction{queueMin}{min}
	\SetKwFunction{queueMinKey}{minKey}
	\SetKwFunction{queueDecreaseKey}{decreaseKey}
	\SetKwFunction{queueContains}{contains}
	\SetKwFunction{listInsert}{insert}
	\SetKwFunction{removeDom}{removeDominated}
	\SetKwFunction{settleNextNode}{settleNextNode}

	% Algorithm interface
	\KwIn{Graph $G=(V,E,\mathfunction{len})$, set of parking nodes $P \subseteq V$, a set of driving time constraints $R = \{r\}$, start and target nodes $s,t \in V$, potential $\concretepotential_t()$}
	\KwData{Priority queue \Q, per node set \L{$v$} of labels for all $v \in V$}
	\KwOut{Shortest journey with $\concretett(j) = \traveltime(s,t)$}

	% The algorithm
	\BlankLine
	\tcp{Initialization}
	$l_s \leftarrow (0,0,\bot)$\;
	\Q.\queueInsert{$\concretepotential_t((l_s),s)$, $l_s$}\;
	\L{$s$}.\setInsert{$l_s$}\;
	\BlankLine
	\tcp{Main loop}
	\While{\Q is not empty}
	{
		\settleNextNode{}\;

		\If{\text{minimum of $Q$ is label at $t$}}
		{
			\Return\;
		}
	}
\end{algorithm}

The only thing left is the adaption of \textsc{relaxEdge'} in fig. \ref{alg:relax_edge} where we change the queue keys to use $\concretett(l) + \potential_t(l,v)$ instead. The result is shown in fig. \ref{alg:relax_edge_a_star}.

\begin{figure}[hbtp]
	\setlength{\interspacetitleruled}{0pt}%
	\setlength{\algotitleheightrule}{0pt}%
	\begin{algorithm*}[H]
		\SetFuncSty{textsc}
		\DontPrintSemicolon
		\SetKwData{Q}{Q}
		\SetKwData{L}{L}

		\SetKwFunction{relaxEdge}{relaxEdge}
		\SetKwFunction{queueDeleteMin}{deleteMin}

		\SetKwData{Q}{Q}
		\SetKwData{L}{L}
		\SetKwData{D}{D}
		\SetKwData{pred}{pred}
		\SetKwArray{ds}{ds}
		\SetKwFunction{queueDeleteMin}{deleteMin}
		\SetKwFunction{queueInsert}{queueInsert}
		\SetKwFunction{setInsert}{insert}
		\SetKwFunction{queueMin}{min}
		\SetKwFunction{queueMinKey}{minKey}
		\SetKwFunction{queueDecreaseKey}{decreaseKey}
		\SetKwFunction{queueContains}{contains}
		\SetKwFunction{listInsert}{insert}
		\SetKwFunction{removeDom}{removeDominated}

		\SetKwProg{Pn}{Procedure}{:}{\KwRet}
		\Pn{\relaxEdge{(u,v), l}}{
			\If{$\breakDist(l) + \mathfunction{len}(u,v) < \restr_d$}
			{
				\D.\setInsert{$(\concretett(l) + \mathfunction{len}(u,v), \breakDist(l) + \mathfunction{len}(u,v), l)$}\;

				\If{$v \in P$}
				{
					\D.\setInsert{$(\concretett(l) + \mathfunction{len}(u,v) + \breakDist_p, 0, l)$}\;
				}

				\ForAll{ $l' \in D$ }
				{
					\If{$l'$ is not dominated by any label in \L{$v$}}
					{
						\L{$v$}.\removeDom{$l'$} \;
						\L{$v$}.\setInsert{$l'$} \;
						\Q.\queueInsert{$\concretett(l') + \concretepotential_t(l')$, l'}
					}
				}
			}
		}
	\end{algorithm*}
	\setlength{\interspacetitleruled}{2pt}%
	\setlength{\algotitleheightrule}{\algotitleheightruledefault}%

	\caption{\label{alg:relax_edge_a_star} Relaxing an edge with regard to the potential.}
\end{figure}

\subsection{Potential for One Driving Time Constraint}\label{section:potential_csp}
Given a target node $t$, the CH potential $\chpotential_t(v)$ yields a perfect estimate for the distance $\distance(v,t)$ from $v$ to $t$ without regard for driving time constraints and breaks which also trivially is a lower bound for the remaining travel time for any label at $v$. A better lower bound for the remaining travel time of a label from $v$ to $t$, including breaks due to the driving time limit, can be calculated by taking the minimum necessary amount of breaks into account. We define \minBreaks as a function which calculates the minimum amount of necessary breaks given a driving time $d$.

\begin{align}\label{eq:min_breaks}
	\minBreaks(d) = \begin{dcases}
		\ceil*{ \frac{d}{\restr_d} } - 1 & d > 0 \\
		0                                & else
	\end{dcases}
\end{align}

We now can calculate a lower bound for the necessary break time given a driving time $d$

\begin{align}\label{eq:min_break_time}
	\minBreakTime(d) = \minBreaks(d) \cdot r_p
\end{align}

and finally define our node potential as

\begin{align}
	\concretepotential{'}_t(v) & = \minBreakTime(d) + \chpotential_t(v) \\
	                           & = \minBreakTime(d) + \distance(v,t)
\end{align}

A node potential is called \emph{feasible} if it does not overestimate the distance of any edge in the graph, i.e.

\begin{align}
	\label{eq:node_potential_feasibility}
	len(u,v) - \concretepotential_t(u) + \concretepotential_t(v) \ge 0 \quad \forall (u,v) \in E
\end{align}

A feasible node potential allows us to stop the A* search when the node $t$, respectively the first label at $t$, was removed from the queue. Following example of a query using the graph in Fig. \ref{fig:graph_infeasible_potential} shows that $\concretepotential{'}_t$ is not feasible. With a driving time limit of 6 and a break time of 1, the potential here will yield a value $\concretepotential_t(s) = 8$ since the potential includes the minimum required break time for a path from s to t. Consequently, with $\concretepotential{'}_t(v) = 5$ and $len(s,v) = 2$, $len(s,v) - \concretepotential{'}_t(s) + \concretepotential{'}_t(v) = -1$.

\begin{figure}[hbtp]
	\centering
	\input{figures/graph_infeasible_potential.tex}
	\caption{A graph with the potential to break the potential.}
	\label{fig:graph_infeasible_potential}
\end{figure}

A variant of the potential accounts for the driving time since the last break of a label $\breakDist(l)$ to calculate the minimum required break time on the $v$-$t$ path. Since the potential now uses information from a label $l$ with $l \in L(v)$, it no longer is a node potential but also depends on the chosen label at $v$.

\begin{align}
	\concretepotential_t(l,v) & = \minBreakTime(\breakDist(l) + \chpotential(v)) +\chpotential(v) \\
	                          & = \minBreakTime(\breakDist(l) + \distance(v,t)) + \distance(v,t)
\end{align}

Since the potential $\concretepotential_t$ now uses label information, it no longer is a node potential and the feasibility definition as defined in inequality \ref{eq:node_potential_feasibility} can no longer be applied. We still want to use potential and label information to calculate lower bound estimates for the length of paths. We therefore have to show that queue keys of labels, which represent a lower bound estimate for the travel time of the entire journey, can only increase over time.

\begin{lemma}\label{lemma:pot_labels_get_larger}
	Let $p = \langle s=v_0,v_1,\ldots,t=v_k, \rangle$ be a path with labels $l_i$ at nodes $v_i$. Then $\concretett(l_{i-1}) + \concretepotential_t(l_{i-1},v_{i-1}) \le \concretett(l_i) + \concretepotential_t(l_i,v_i)$.
\end{lemma}

\begin{proof}
	Let $(u,v) \in E$ be an edge. The procedure \textsc{relaxEdge} in fig. \ref{alg:relax_edge_a_star} can produce two new labels at a node $v$ for each label at $u$, depending on if $v$ is a parking node. We differentiate the two cases not parking at $v$ and parking at $v$. Let $l \in L(u)$ and $l' \in L(v)$.

	Following general observations can be made:

	\begin{enumerate}
		\item $d > d' \implies \minBreakTime(d) > \minBreakTime(d')$
		\item $\minBreakTime(d + \restr_d) = \restr_b + \minBreakTime(d)$
		\item $\restr_d > \breakDist(l') \ge \breakDist(l) + \len(u,v) \ge \breakDist(l)$\\(line $2$ in \textsc{relaxEdge} in fig. \ref{alg:relax_edge_a_star})
		\item   $\len(u,v) - \chpotential_t(u)+ \chpotential_t(v) \ge 0$ (feasibility of the CH potential)
		\item  $\len(u,v) + \chpotential_t(v) \ge \chpotential_t(u)$
	\end{enumerate}

	We show that $\concretett(l_i) + \concretepotential_t(l_i,v_i) - \concretett(l_{i-1}) - \concretepotential_t(l_{i-1},v_{i-1}) \ge 0$.

	\emph{Case 1: Not parking at $v$.} In this case, $\concretett(l') = \concretett(l) + \len(u,v)$ and $\breakDist(l') = \breakDist(l) + \len(u,v)$.

	\begin{align}
		\begin{split}\label{eq:label_feasibility_proof_1}
			&\concretett(l') - \concretett(l) - \concretepotential_t(l,u) + \concretepotential_t(l',v)\\
			&= \concretett(l) + \len(u,v) - \concretett(l)\\
			& \phantom{{}=1} - (\minBreakTime(\breakDist(l)+\chpotential(u)) + \chpotential(u))\\
			& \phantom{{}=1} + \minBreakTime(\breakDist(l')+\chpotential(v)) + \chpotential(v)\\
			&= \len(u,v) + \minBreakTime(\breakDist(l')+\chpotential(v))\\
			& \phantom{{}=1} - \minBreakTime(\breakDist(l)+\chpotential(u)) - \chpotential(u) + \chpotential(v)\\
			&= \len(u,v) + \minBreakTime(\breakDist(l) + \len(u,v) + \chpotential(v))\\
			& \phantom{{}=1} - \minBreakTime(\breakDist(l)+\chpotential(u)) - \chpotential(u) + \chpotential(v) \\
			&\stackrel{\text{(1. and 5.)}}{\ge} \len(u,v) + \minBreakTime(\breakDist(l) + \chpotential(u))\\
			& \phantom{{}=1} - \minBreakTime(\breakDist(l)+\chpotential(u)) - \chpotential(u) + \chpotential(v) \\
			&= \len(u,v) - \chpotential(u) + \chpotential(v)\\
			&\stackrel{\text{(4.)}}{\ge} 0
		\end{split}
	\end{align}

	\emph{Case 2: Parking at $v$.} In this case, $\concretett(l') = \concretett(l) + \len(u,v) + \restr_b$ and $\breakDist(l') = 0$.

	\begin{align}
		\begin{split}\label{eq:label_feasibility_proof_2}
			&\concretett(l') - \concretett(l) - \concretepotential_t(l,u) + \concretepotential_t(l',v)\\
			&= \concretett(l) + \len(u,v) + \restr_b - \concretett(l)\\
			& \phantom{{}=1} - (\minBreakTime(\breakDist(l)+potential(u)) + potential(u))\\
			& \phantom{{}=1} + \minBreakTime(\chpotential(v)) + \chpotential(v)\\
			&=  \len(u,v) + \restr_b + \minBreakTime(\chpotential(v))\\
			& \phantom{{}=1} - \minBreakTime(\breakDist(l)+\chpotential(u)) - \chpotential(u) + \chpotential(v)\\
			&\stackrel{\text{(2.)}}{=}  \len(u,v) + \minBreakTime(\restr_d + \chpotential(v))\\
			& \phantom{{}=1} - \minBreakTime(\breakDist(l)+\chpotential(u)) - \chpotential(u) + \chpotential(v)\\
			&\stackrel{\text{(1. and 3.)}}{\ge} \len(u,v) + \minBreakTime(\breakDist(l) + \len(u,v) + \chpotential(v))\\
			& \phantom{{}=1} - \minBreakTime(\breakDist(l)+\chpotential(u)) - \chpotential(u) + \chpotential(v)\\
			&\stackrel{\text{(1. and 4.)}}{\ge} \len(u,v) + \minBreakTime(\breakDist(l) + \chpotential(u))\\
			& \phantom{{}=1} - \minBreakTime(\breakDist(l)+\chpotential(u)) - \chpotential(u) + \chpotential(v)\\
			&=  \len(u,v) - \chpotential(u) + \chpotential(v)\\
			&\stackrel{\text{(4.)}}{\ge} 0
		\end{split}
	\end{align}
\end{proof}

TODO is this even necessary?
\begin{lemma}\label{lemma:pot_lower_boundist_csp}
	The potential $\concretepotential_t(l,v)$ of a label $l$ at a node $v$ is a lower bound for the distance including breaks from $v$ to $t$.
\end{lemma}

\begin{proof}
	Let $p = \langle s=v_0,v_1,\ldots,t=v_k, \rangle$ be a path with labels $l_i$ at nodes $v_i$. With $\concretett(l_{i-1}) + \concretepotential_t(l_{i-1},v_{i-1}) \ge \concretett(l_{i}) + \concretepotential_t(l_i,v_i)$ for all edges on $p$, the total length $len(p)$ of the path must follow $\concretepotential_t(l_i,v_i) \le len(p) + \concretepotential_t(l_k,t) \Leftrightarrow l(p) \ge \concretepotential_t(l_i,v_i) - \concretepotential_t(l_k,t)$. Since $\concretepotential_t(l_k,t) = 0$, $l(p) \ge \concretepotential_t(l_i,v_i)$ holds.
\end{proof}

\begin{theorem}\label{theorem:pot_stop_criterion}
	The search can be stopped when the first label at $t$ is removed from the queue.
\end{theorem}

\begin{proof}
	When a label $l$ at $t$ is removed from the queue during a $s$-$t$ query, all remaining label $m$ of a node $v$ in the queue fulfill $\concretett(t) + \concretepotential_t(l,t) \le \concretett(v) + \concretepotential_t(m,v)$. Assume that $\concretett(t)$ is not the shortest distance from $s$ to $t$. Then, a shorter path $p = \langle s=v_0,v_1,\ldots,t=v_k, \rangle$ exists which uses at least one unsettled label $m \in L(v_i)$. Since $l$ was already removed from the queue, $\concretett(t) = \concretett(t) + \concretepotential_t(l,t) \le  \concretett(v) + \concretepotential_t(m,v) \le l(p)$ which contradicts the assumption that $p$ yields a shorter $s$-$t$ distance than $\concretett(t)$.
\end{proof}

\section{Multiple Driving Time Constraints}
Dijkstra's algorithm with one driving time constraint (1-DTC) can easily be adapted to handle multiple driving time constraints $\restr_i$. We abbreviate the generalized problem \emph{n-DTC}. For a number of $n$ driving time constraints, a label now contains the total travel time $\concretett$ and $n$ driving time values $\breakDist_1, \ldots , \breakDist_n$. Each $dist_i$ represents the driving time since the last break at a node $v$ with break time $\rho(v) \ge \restr_{i,b}$. Pausing at a node occurs with one of the available break times $\restr_{i,b}$ of a driving time constraint $\restr_i \in R$. Pausing with an arbitrary break time is possible but yields longer travel times and no advantage. When a path breaks at $v$ for a time $\restr_{i,b}$, the corresponding label $l \in L(v)$ has $dist_j(l) = 0$ for all $0 < j \le i$ since the breaks with shorter break times are \emph{included} in the longer break.

\paragraph{Label Propagation.}
Label propagation simply extends the component-wise addition of the edge weight to all elements of the distance vector. Let $l \in L(u)$ be a label at $u$ and $(u,v) = e \in E$, then $l$ can be propagated to $v$ resulting in a label $l'$ with $dist_i(l') = \breakDist_i(l) + \mathfunction{len}(e)$ $\forall i \le |R|$, and $\pred(l') = l$.

\paragraph{Label Pruning.}
The pruning rule for driving time constraints generalizes is a similar way. A label is discarded if $dist_i(l) \ge \restr_{d,i}$ for any $i$ with $0 < i \le |R|$.


\paragraph{Label Dominance}
At last, label dominance can be generalized to multiple driving time constraints as follows.
\begin{definition}[Label Dominance]
	A label $l \in L(v)$ dominates another label $m \in L(v)$ if $dist_i(m) \ge \breakDist_i(l)$ $\forall i \le |R|$.
\end{definition}

\section{Potential for Multiple Driving Time Constraints\label{section:potential_n_csp}}
TODO: Rewrite for only two dtc?
In section \ref{section:potential_csp} we defined the potential $\concretepotential_t(l,v)$ to extend Dijkstra to an A* search with one driving time constraint. We will now generalize $\concretepotential_t$ for the use with an arbitrary number $n$ of driving time constraints.

To calculate $\concretepotential_t(l,v)$, we used the distance without regard for pausing from $v$ to $t$ and the distance $\breakDist_1(l)$ to calculate a lower bound for the amount of necessary breaks until we reach the target node. With one driving time constraint it is

\[\textit{minimum number of breaks} = \floor*{ \frac{dist_{1}(l) + \drivingtime(v,t)}{t_{d,i}} }.\]

We now have to calculate the lower bound with respect to the different driving time constraints. How many breaks of which duration do we need at least to comply with all driving time constraints $\restr_i$? We need a smaller or equal amount of breaks for longer driving time constraints since they have a longer maximum allowed driving time $\restr_{d,i}$. At the same time, a break of length $\restr_{b,i}$ will also include a break of lengths $\restr_{b,j}$ with $j < i$. We therefore start with calculating the amount of necessary breaks of the longest restriction $r_n$. Then, we calculate how many breaks we need at least for the next smaller constraint and subtract the amount of breaks we just calculated for $r_n$. We repeat this process for each remaining driving time constraint and accumulate the product of number of breaks for $\restr_i$ and its corresponding break time $\restr_{b,i}$ to yield the minimum total break time on the remaining path to $t$. Finally, we add the raw driving time $\drivingtime{v,t}$. We now can define $\concretepotential_t$ as

\begin{align}\label{eq:multiple_breaks_pot}
	\concretepotential_t(l,v) & = \drivingtime(v,t) + \sum_{i=1}^n{ n_i * \restr_{b,i}}
\end{align}

with

\begin{align}\label{eq:number_breaks}
	n_i =\begin{dcases}
		\floor*{ \frac{dist_{i}(l) + \drivingtime(v,t)}{\restr_{d,i}} } - \floor*{ \frac{dist_{i+1}(l) + \drivingtime(v,t)}{t_{d,i+1}} } & 0 < i < n \\
		\floor*{ \frac{dist_{i}(l) + \drivingtime(v,t)}{\restr_d} }                                                                      & i=n
	\end{dcases}
\end{align}

The value of $n_i$ for $0 < i < n$ can also be calculated by reusing already computed values $n_j$ with $j > i$:

\begin{align*}
	n_i =\begin{dcases}
		\floor*{ \frac{dist_{i}(l) + \drivingtime(v,t)}{\restr_{d,i}} } - \sum_{j=i+1}^{n}{n_{j} } & 0 < i < n \\
		\floor*{ \frac{dist_{i}(l) + \drivingtime(v,t)}{\restr_d} }                                & i=n
	\end{dcases}
\end{align*}

If lemma \ref{lemma:pot_labels_get_larger} still holds then lemma \ref{lemma:pot_lower_boundist_csp} and theorem \ref{theorem:pot_stop_criterion} follow as a consequence.

% \begin{lemma}
% 	Lemma \ref{lemma:pot_labels_get_larger} still holds for an arbitrary number $n$ of driving time constraints.
% \end{lemma}

% \begin{proof}
% 	Given a Graph $G=(V,E)$ with a set of parking nodes $P \subseteq V$, let $p = \langle s=v_0,v_1,\ldots,t=v_k, \rangle$ be a path in G with labels $l_i$ at nodes $v_i$. Let $l_{i-1}$ and $l_{i}$ label at nodes $v_{i-1}$ and $v_i$. In the proof of lemma \ref{lemma:pot_labels_get_larger} we considered the two cases of parking at $v_i$ and not parking at $v_i$. In the first case, the last used parking node of the two labels will not be the same, in the second case it will be the same node. We cannot simply differentiate these two cases now because we not only decide if we use a parking node or not, but we also decide how long the break will be. Let $R$ be the set of driving time constraints $\restr_j$. If a label uses $v_i$ as a parking node with a break time of $\restr_{b,k}$, then it fulfills the break requirements for a break for all driving time constraints $\restr_j$ with $0 < j \le k$. Therefore, $\breakDist_1(l_i) = \ldots = \breakDist_k(l_i) = 0$ and for $k < j \le |R|$ is the last parking node of $l_{i-1}$ and $l_i$ the same node which we name $p_j \in P \cup \{s\}$.

% 	It is

% 	\begin{align}
% 		\begin{split}\label{eq:label_n_feasibility_proof_1}
% 			\concretett(l_{i}) + \concretepotential_t(l_{i},v_{i}) & = \traveltime(s,v_{i}) + \drivingtime(v_i,t) + \sum_{j=1}^{n-1}{ n_j * \restr_{b,j}}\\
% 			& = \traveltime(s,v_{i}) + \drivingtime(v_i,t) + \sum_{j=1}^n{ \floor*{ \frac{dist_{j}(l) + \drivingtime(v_i,t)}{\restr_{d,j}} } - \floor*{ \frac{dist_{j+1}(l) + \drivingtime(v_i,t)}{t_{d,j+1}} } * \restr_{b,j}}\\
% 			& \phantom{{}=1} + \floor*{ \frac{dist_{n}(l) + \drivingtime(v_i,t)}{\restr_{d,n}} }\\
% 			& = \drivingtime(s,v_{i}) + \drivingtime(v_{i},t) + \textit{break time on s-t path}
% 		\end{split}
% 	\end{align}


% 	Since $\drivingtime(s,v_{i-1}) + \drivingtime(v_{i-1},t) = \drivingtime(s,v_i) + \drivingtime(v_i,t)$, we only have to proof that


% 	We $\concretett(l_{i-1}) + \concretepotential_t(l_{i-1},v_{i-1}) \le \concretett(l_i) + \concretepotential_t(l_i,v_i)$.

% 	\begin{align}
% 		\begin{split}\label{eq:label_n_feasibility_proof_2}
% 			\concretett(l_{i-1}) + \concretepotential_t(l_{i-1},v_{i-1}) &= \traveltime(s,v_{i-1}) + \drivingtime(v_{i-1},t)\\
% 			& + \sum_{j=1}^{n-1}{\left(\floor*{\frac{\drivingtime(p_j,v_{i-1}) + \drivingtime(v_{i-1},t)}{\restr_{b,j}}} - \floor*{\frac{\drivingtime(p_j,v_{i-1}) + \drivingtime(v_{i-1},t)}{\restr_{b,j+1}}}\right) * \restr_{d,j}}\\
% 			& + \floor*{\frac{\drivingtime(p_n,v_{i-1}) + \drivingtime(v_{i-1},t)}{\restr_{b,n}}} * \restr_{d,n}\\
% 			&= \traveltime(s,v_{i-1}) + \drivingtime(v_{i-1},t)\\
% 			& + \sum_{j=1}^{k-1}{\left(\floor*{\frac{\drivingtime(p_j,v_{i-1}) + \drivingtime(v_{i-1},t)}{\restr_{b,j}}} - \floor*{\frac{\drivingtime(p_j,v_{i-1}) + \drivingtime(v_{i-1},t)}{\restr_{b,j+1}}}\right) * \restr_{d,j}}\\
% 			& + \floor*{\frac{\drivingtime(p_n,v_{i-1}) + \drivingtime(v_{i-1},t)}{\restr_{b,n}}} * \restr_{d,n}
% 		\end{split}
% 	\end{align}

% 	\begin{align}
% 		\begin{split}
% 			\traveltime(s,p) + \drivingtime(p,v_{i-1}) + \drivingtime(v_{i-1},t)\\
% 			& \phantom{{}=1} + \floor*{ \frac{\drivingtime(p,v_{i-1}) + \drivingtime(v_{i-1},t)}{\restr_d} } * \restr_p\\
% 			&= \traveltime(s,p) + \drivingtime(p,v_{i}) + \drivingtime(v_{i},t)\\
% 			& \phantom{{}=1} + \floor*{ \frac{\drivingtime(p,v_{i}) + \drivingtime(v_{i},t)}{\restr_d} } * \restr_p\\
% 			&\le \traveltime(s,p) + \traveltime(p,q) - \restr_b+ \drivingtime(v_{i},t)\\
% 			& \phantom{{}=1} + \floor*{ \frac{\drivingtime(v_{i},t)}{\restr_d} } * \restr_b+ \restr_p\\
% 			&= \traveltime(s,q) + 0 + \drivingtime(v_{i},t)\\
% 			& \phantom{{}=1} + \floor*{ \frac{0 + \drivingtime(v_{i},t)}{\restr_d} } * \restr_p\\
% 			&= \traveltime(s,q) + \drivingtime(q,v_{i}) + \drivingtime(v_{i},t)\\
% 			& \phantom{{}=1} + \floor*{ \frac{\drivingtime(q,v_{i}) + \drivingtime(v_{i},t)}{\restr_d} } * \restr_p\\
% 			&= \concretett(l_{i}) + \concretepotential_t(l_{i1},v_{i})
% 		\end{split}
% 	\end{align}
% \end{proof}

\begin{lemma}
	Lemma \ref{lemma:pot_labels_get_larger} still holds for two driving time constraints.
\end{lemma}

\begin{proof}
	Given a Graph $G=(V,E)$ with a set of parking nodes $P \subseteq V$, let $p = \langle s=v_0,v_1,\ldots,t=v_k, \rangle$ be a path in G with labels $l_i$ at nodes $v_i$. Let $l_{i-1}$ and $l_{i}$ label at nodes $v_{i-1}$ and $v_i$. In the proof of lemma \ref{lemma:pot_labels_get_larger} we considered the two cases of parking at $v_i$ and not parking at $v_i$. In the first case, the last used parking node of the two labels will not be the same, in the second case it will be the same node. We now have two different driving time constraints and have to consider three cases: not parking at $v_i$ and parking at $v_i$ with break time $r_{1,b}$ or $r_{2,b}$. It is

	\begin{align}
		\begin{split}\label{eq:label_2_feasibility_proof_1}
			\concretett(l_{i-1}) + \concretepotential_t(l_{i-1},v_{i-1}) &= \concretett(l_{i-1}) + \floor*{ \frac{\breakDist_1(l_{i-1}) + \drivingtime(v_{i-1},t)}{\restr_{2,d}} } * \restr_{2,b}\\
			& \phantom{{}=1} + \left(\floor*{\frac{\breakDist_1(l_{i-1}) + \drivingtime(v_{i-1},t)}{\restr_{1,d}} } - \floor*{\frac{\breakDist_1(l_{i-1}) + \drivingtime(v_{i-1},t)}{\restr_{2,d}} }\right) * \restr_{1,b} + \drivingtime(v_{i-1},t)\\
			&= \concretett(l_{i-1}) + \drivingtime(v_{i-1},t) + \floor*{ \frac{\drivingtime(p_2,v_{i-1}) + \drivingtime(v_{i-1},t)}{\restr_{2,d}} } * \restr_{2,b}\\
			& \phantom{{}=1}+ \left( \floor*{ \frac{\drivingtime(p_1,v_{i-1})  + \drivingtime(v_{i-1},t)}{\restr_{1,d}} } - \floor*{ \frac{\drivingtime(p_2,v_{i-1}) + \drivingtime(v_{i-1},t)}{\restr_{2,d}} }\right) * \restr_{1,b}\\
			&= \traveltime(s, p_1) + \drivingtime(p_1,v_{i-1}) + \drivingtime(v_{i-1},t)\\
			& \phantom{{}=1} + \floor*{ \frac{\drivingtime(p_2,p_1) + \drivingtime(p_1,v_{i-1}) + \drivingtime(v_{i-1},t)}{\restr_{2,d}} } * \restr_{2,b}\\
			& \phantom{{}=1} + \left( \floor*{ \frac{\drivingtime(p_1,v_{i-1})  + \drivingtime(v_{i-1},t)}{\restr_{1,d}} } - \floor*{ \frac{\drivingtime(p_2,p_1) + \drivingtime(p_1,v_{i-1}) + \drivingtime(v_{i-1},t)}{\restr_{2,d}} }\right) * \restr_{1,b}
		\end{split}
	\end{align}.

	\emph{Case 1: Not parking at $v_i$}. It is $p_i=q_i$ for $i \in \{1,2\}$. Similar to equation \ref{eq:label_feasibility_proof_2} we show

	\begin{align}
		\begin{split}\label{eq:label_2_feasibility_proof_2}
			\drivingtime(p_i,v_{i-1}) + \drivingtime(v_{i-1},t) & = \drivingtime(p_i,v_{i-1}) + len(v_{i-1},v_i) + \drivingtime(v_i,t) \\
			& = \drivingtime(q_i,v_{i-1}) + len(v_{i-1},v_i) + \drivingtime(v_i,t) \\
			& = \drivingtime(q_i,v_i) + \drivingtime(v_i,t)
		\end{split}
	\end{align}

	With equation \ref{eq:label_2_feasibility_proof_1} follows

	\begin{align}
		\begin{split}\label{eq:label_2_feasibility_proof_3}
			\concretett(l_{i-1}) + \concretepotential_t(l_{i-1},v_{i-1}) &= \traveltime(s, p_1) + \drivingtime(p_1,v_{i-1}) + \drivingtime(v_{i-1},t)\\
			& \phantom{{}=1} + \floor*{ \frac{\drivingtime(p_2,p_1) + \drivingtime(p_1,v_{i-1}) + \drivingtime(v_{i-1},t)}{\restr_{2,d}} } * \restr_{2,b}\\
			& \phantom{{}=1} + \left( \floor*{ \frac{\drivingtime(p_1,v_{i-1})  + \drivingtime(v_{i-1},t)}{\restr_{1,d}} } - \floor*{ \frac{\drivingtime(p_2,p_1) + \drivingtime(p_1,v_{i-1}) + \drivingtime(v_{i-1},t)}{\restr_{2,d}} }\right) * \restr_{1,b}\\
			&= \traveltime(s, q_1) + \drivingtime(q_1,v_{i}) + \drivingtime(v_{i},t)\\
			& \phantom{{}=1} + \floor*{ \frac{\drivingtime(q_2,q_1) + \drivingtime(q_1,v_{i}) + \drivingtime(v_{i},t)}{\restr_{2,d}} } * \restr_{2,q}\\
			& \phantom{{}=1} + \left( \floor*{ \frac{\drivingtime(q_1,v_{i})  + \drivingtime(v_{i},t)}{\restr_{1,d}} } - \floor*{ \frac{\drivingtime(q_2,q_1) + \drivingtime(q_1,v_{i}) + \drivingtime(v_{i},t)}{\restr_{2,d}} }\right) * \restr_{1,q}\\
			&=\concretett(l_{i}) + \concretepotential_t(l_{i},v_{i})
		\end{split}
	\end{align}

	\emph{Case 2: Short break at $v_i$}. It is $p_1 \neq q_1 \land p_2 = q_2$. In this case, $q_1 = v_i$ and $\traveltime(p_1,v_i) = \traveltime(p_1,q_1) = \drivingtime(p_1,v_i) + \restr_{1,b}$. With \ref{eq:label_2_feasibility_proof_1} follows

	\begin{align}
		\begin{split}\label{eq:label_2_feasibility_proof_4}
			\concretett(l_{i-1}) + \concretepotential_t(l_{i-1},v_{i-1}) &= \traveltime(s, p_1) + \drivingtime(p_1,v_{i-1}) + \drivingtime(v_{i-1},t)\\
			& \phantom{{}=1} + \floor*{ \frac{\drivingtime(p_2,p_1) + \drivingtime(p_1,v_{i-1}) + \drivingtime(v_{i-1},t)}{\restr_{2,d}} } * \restr_{2,b}\\
			& \phantom{{}=1} + \left( \floor*{ \frac{\drivingtime(p_1,v_{i-1})  + \drivingtime(v_{i-1},t)}{\restr_{1,d}} } - \floor*{ \frac{\drivingtime(p_2,p_1) + \drivingtime(p_1,v_{i-1}) + \drivingtime(v_{i-1},t)}{\restr_{2,d}} }\right) * \restr_{1,b}\\
			&= \traveltime(s, p_1) + \drivingtime(p_1,v_{i}) + \drivingtime(v_{i},t)\\
			& \phantom{{}=1} + \floor*{ \frac{\drivingtime(p_2,p_1) + \drivingtime(p_1,v_{i}) + \drivingtime(v_{i},t)}{\restr_{2,d}} } * \restr_{2,b}\\
			& \phantom{{}=1} + \left( \floor*{ \frac{\drivingtime(p_1,v_{i})  + \drivingtime(v_{i},t)}{\restr_{1,d}} } - \floor*{ \frac{\drivingtime(p_2,p_1) + \drivingtime(p_1,v_{i}) + \drivingtime(v_{i},t)}{\restr_{2,d}} }\right) * \restr_{1,b}\\
			&\le \traveltime(s, p_1) + \traveltime(p_1,q_1) - r_{1,b} + \drivingtime(v_{i},t)\\
			& \phantom{{}=1} + \floor*{ \frac{\drivingtime(p_2,p_1) + \drivingtime(p_1,v_{i}) + \drivingtime(v_{i},t)}{\restr_{2,d}} } * \restr_{2,b}\\
			& \phantom{{}=1} + \left( \floor*{ \frac{\drivingtime(v_{i},t)}{\restr_{1,d}} } - \floor*{ \frac{\drivingtime(p_2,p_1) + \drivingtime(p_1,v_{i}) + \drivingtime(v_{i},t)}{\restr_{2,d}} }\right) * \restr_{1,b} + r_{1,b}\\
			&= \traveltime(s, q_1) + 0 + \drivingtime(v_{i},t)\\
			& \phantom{{}=1} + \floor*{ \frac{\drivingtime(q_2,p_1) + \drivingtime(p_1,q_{1}) + 0 + \drivingtime(v_{i},t)}{\restr_{2,d}} } * \restr_{2,b}\\
			& \phantom{{}=1} + \left( \floor*{ \frac{0 + \drivingtime(v_{i},t)}{\restr_{1,d}} } - \floor*{ \frac{\drivingtime(q_2,p_1) + \drivingtime(p_1,q_{1}) + 0 + \drivingtime(v_{i},t)}{\restr_{2,d}} }\right) * \restr_{1,b}\\
			&= \traveltime(s, q_1) + \drivingtime(q_1,v_{i}) + \drivingtime(v_{i},t)\\
			& \phantom{{}=1} + \floor*{ \frac{\drivingtime(q_2,q_1) + \drivingtime(q_1,v_{i}) + \drivingtime(v_{i},t)}{\restr_{2,d}} } * \restr_{2,q}\\
			& \phantom{{}=1} + \left( \floor*{ \frac{\drivingtime(q_1,v_{i})  + \drivingtime(v_{i},t)}{\restr_{1,d}} } - \floor*{ \frac{\drivingtime(q_2,q_1) + \drivingtime(q_1,v_{i}) + \drivingtime(v_{i},t)}{\restr_{2,d}} }\right) * \restr_{1,q}\\
			&= \concretett(l_{i}) + \concretepotential_t(l_{i1},v_{i})
		\end{split}
	\end{align}

	\emph{Case 3: Long break at $v_i$}. It is $p_j \neq q_j$ for $i \in \{1,2\}$ In this case, $q_j = v_i$ and $\traveltime(p_j,v_i) = \traveltime(p_j,q_j) = \drivingtime(p_j,v_i) + \restr_{2,b}$. With \ref{eq:label_2_feasibility_proof_1} follows

	\begin{align}
		\begin{split}\label{eq:label_2_feasibility_proof_5}
			\concretett(l_{i-1}) + \concretepotential_t(l_{i-1},v_{i-1}) &= \traveltime(s, p_1) + \drivingtime(p_1,v_{i-1}) + \drivingtime(v_{i-1},t)\\
			& \phantom{{}=1} + \floor*{ \frac{\drivingtime(p_2,p_1) + \drivingtime(p_1,v_{i-1}) + \drivingtime(v_{i-1},t)}{\restr_{2,d}} } * \restr_{2,b}\\
			& \phantom{{}=1} + \left( \floor*{ \frac{\drivingtime(p_1,v_{i-1})  + \drivingtime(v_{i-1},t)}{\restr_{1,d}} } - \floor*{ \frac{\drivingtime(p_2,p_1) + \drivingtime(p_1,v_{i-1}) + \drivingtime(v_{i-1},t)}{\restr_{2,d}} }\right) * \restr_{1,b}\\
			&= \traveltime(s, p_1) + \drivingtime(p_1,v_{i}) + \drivingtime(v_{i},t)\\
			& \phantom{{}=1} + \floor*{ \frac{\drivingtime(p_2,p_1) + \drivingtime(p_1,v_{i}) + \drivingtime(v_{i},t)}{\restr_{2,d}} } * \restr_{2,b}\\
			& \phantom{{}=1} + \left( \floor*{ \frac{\drivingtime(p_1,v_{i})  + \drivingtime(v_{i},t)}{\restr_{1,d}} } - \floor*{ \frac{\drivingtime(p_2,p_1) + \drivingtime(p_1,v_{i}) + \drivingtime(v_{i},t)}{\restr_{2,d}} }\right) * \restr_{1,b}\\
			&\le \traveltime(s, p_1) + \traveltime(p_1,v_{i}) - r_{2,b} + \drivingtime(v_{i},t)\\
			& \phantom{{}=1} + \floor*{ \frac{\drivingtime(v_{i},t)}{\restr_{2,d}} } * \restr_{2,b} + \restr_{2,b}\\
			& \phantom{{}=1} + \left( \floor*{ \frac{\drivingtime(v_{i},t)} {\restr_{1,d}} } - \floor*{\frac{\drivingtime(v_{i},t)}{\restr_{2,d}} } \underbrace{+ 1}_\text{this breaks it, can it go?} \right) * \restr_{1,b}\\
			&= \traveltime(s, q_1) + \drivingtime(v_{i},t)\\
			& \phantom{{}=1} + \floor*{ \frac{0 + 0 + \drivingtime(v_{i},t)}{\restr_{2,d}} } * \restr_{2,b}\\
			& \phantom{{}=1} + \left( \floor*{ \frac{0 + \drivingtime(v_{i},t)} {\restr_{1,d}} } - \floor*{\frac{0 + 0 + \drivingtime(v_{i},t)}{\restr_{2,d}} } \right) * \restr_{1,b}\\
			&= \traveltime(s, q_1) + \drivingtime(q_1,v_{i}) + \drivingtime(v_{i},t)\\
			& \phantom{{}=1} + \floor*{ \frac{\drivingtime(q_2,q_1) + \drivingtime(q_1,v_{i}) + \drivingtime(v_{i},t)}{\restr_{2,d}} } * \restr_{2,q}\\
			& \phantom{{}=1} + \left( \floor*{ \frac{\drivingtime(q_1,v_{i})  + \drivingtime(v_{i},t)}{\restr_{1,d}} } - \floor*{ \frac{\drivingtime(q_2,q_1) + \drivingtime(q_1,v_{i}) + \drivingtime(v_{i},t)}{\restr_{2,d}} }\right) * \restr_{1,q}\\
			&= \concretett(l_{i}) + \concretepotential_t(l_{i},v_{i})
		\end{split}
	\end{align}
\end{proof}

TODO um das +1 wegzukriegen muss man zeigen, dass auf kürzesten pfaden eine große Pause auch eine kleine Pause einspart. damit gilt das ganze auch nicht auf einem beliebigen pfad, sondern nur auf kürzesten pfaden. ansonsten gilt halt $\concretett(l_{i-1}) + \concretepotential_t(l_{i-1},v_{i-1}) \le \concretett(l_{i}) + \concretepotential_t(l_{i},v_{i}) + r_{1,b}$ und der suboptimale pfad kommt weiter hinten in der queue aber das macht nichts kaputt

- das ist gar nicht der Fall, muss anders gehen
% \begin{lemma}
% 	On shortest $s$-$t$ paths, each long break at a node $v$ with a break time of $r_{2,b}$ also includes a necessary short break. In other words, you cannot remove a long break from a shortest path without also violating the short driving time constraint $r_1$.
% \end{lemma}

% \begin{proof}
% 	It is trivial that on a shortest path, it must not be possible to remove a long break from the path without violating $r_2$. We show that this is also true for $r_1$.

% 	Let $u$, $v$, and $w$ be nodes on a shortest $s$-$t$ path. Let there be a long break at $v$. Therefore, it must be $\drivingtime(s,v) \ge r_{2,d}$ or $\drivingtime(v,t) \ge r_{2,d}$, so w.l.o.g let $\drivingtime(s,v) \ge r_{2,d}$. Let's assume that we can remove the break at $v$ without violating $r_1$. Then there must exist a node $u$ with $\drivingtime(u,v) < r_{1,d}$.
% \end{proof}

\section{Bidirectional Search with Multiple Driving Time Constraints}
A common approach to improve constant factors of the runtime of shortest path queries is to start two searches which search for a path in forward direction from $s$ and in backward direction from $t$. The searches ideally meet in the middle, thus halving the theoretical search space of a Dijkstra search since the search radius of each search now is only halve the distance to the target node. The distances of the forward and backward search are combined at nodes which were settled by both searches. Since we aim to stop the search as early as possible, we have to decide on a new stopping criterion which allows the search to stop way before the forward search settles the target node $t$ or the backward search settles $s$. The stopping criterion especially becomes interesting if we use the potential of section \ref{section:potential_n_csp} for a bidirectional A* search.

\subsection{Bidirectional Dijkstra with Multiple Driving Time Constraints}
The input of the search remains a graph $G=(V,E,\mathfunction{len})$, a set of parking nodes $P \subseteq V$, a set of driving time constraints $R$, and start and target nodes $s,t \in V$. We now define the backwards graph $\overleftarrow{G}$ as the Graph $(V,\overleftarrow{E},\overleftarrow{\mathfunction{len}})$ with $\overleftarrow{E} := \{(v,u) \in V \times V : (u,v) \in E\}$ and $\overleftarrow{\mathfunction{len}}(u,v) = \mathfunction{len}(v,u)$. The forward search then is a normal A* search on $G$ with start node $s$ and target node $t$ and the backward search is a normal A* search on $\overleftarrow{G}$ with start node $t$ and target node $s$. Each search owns a queue of labels $\overrightarrow{Q}$ and $\overleftarrow{Q}$ and forward, respectively backward label sets $\overrightarrow{L}(v)$ and $\overleftarrow{L}(v)$ for each $v \in V$. During the search, forward and backward search alternately settle nodes until the stopping criterion is met, one search completed the search by itself, or the queues ran empty. We hold the tentative distance for $\traveltime(s,t)$ in a variable $\tenttraveltime(s,t)$ which we initialize with $\infty$ before settling the first node.

When a search settles a node $v$, it additionally checks if the label set of the other search at $v$ contains any settled labels. If this is the case, forward and backward search met at this node. We then search for the label combination of labels $l \in \overrightarrow{L}(v)$ and $m \in \overleftarrow{L}(v)$ that yields the shortest travel time $\traveltime(s,t) = \traveltime(s,v) + \traveltime(v,t)$ without violating any constraint $r_i$. This is simply done by choosing the labels $l$ and $m$ with minimal $\concretett(l) + \concretett(m)$ while $\breakDist_1(l) + \breakDist_1(m) < r_{1,d}$ and $\breakDist_1(l) + \breakDist_1(m) < r_{2,d}$. If the resulting distance for an $s$-$t$ path via $v$ is smaller than the previously known minimum tentative distance $\tenttraveltime(s,t)$, we update $\tenttraveltime(s,t)$ accordingly. We stop the forward search if the minimum key of $\overrightarrow{Q}$ is greater than $\tenttraveltime(s,t)$ and stop the backward search when the minimum key of $\overleftarrow{Q}$ is greater than $\tenttraveltime(s,t)$.

\begin{theorem}
	At the point in time when forward and backward search have stopped, $\tenttraveltime(s,t) = \traveltime(s,t)$. In other words, when the search stops then $\tenttraveltime(s,t)$ equals the minimum travel time from $s$ to $t$ which complies with the driving time constraints $R$.
\end{theorem}

TODO SPLIT THIS UP INTO PARTS SINCE NO HUMAN CAN UNDERSTAND THIS BLOCK

\begin{proof}
	We first show that when the search stops, all $s$-$t$ paths which comply with the driving time constraints $R$ and which were not found yield a larger travel time $\traveltime(s,t)$ than the current $\tenttraveltime(s,t)$. Then, we show that we don't miss any paths and all paths which comply with the driving time constraints are constructed. That also means that if $\tenttraveltime(s,t) = \infty$ when the search stops, there exist no paths from $s$ to $t$.

	Since the search stops when the minimum key of $\overrightarrow{Q}$ and $\overleftarrow{Q}$ are both greater than $\tenttraveltime(s,t)$, all labels $l$ which will be settled by continuing the search have a greater distance $\concretett(l)$. Therefore, if any new connection between forward and backward search which complies with the driving time constraints will be found, its distance will be greater than $\tenttraveltime(s,t)$.

	The shortest path with travel time $\traveltime(s,t)$ consists of two subpaths of forward and backward search which were connected at a node $v$. There exist label $l \in \overrightarrow{L}$ and $m \in \overleftarrow{L}$ with $\concretett(l) + \concretett(m) = \traveltime(s,t)$. Each label is the result of a unidirectional search from $s$, respectively from $t$. In section \ref{sec:dijkstra_csp_correctness} we proofed that a unidirectional search can be stopped when the first label at its target node was removed from the queue. Since $l$ and $m$ both are smaller or equal to $\tenttraveltime(s,t)$ and both queue keys of forward and backward queue are greater, both $l$ and $m$ where removed from the respective queue. Therefore, we know that $\overrightarrow{L}$ and $\overleftarrow{L}$ contain the labels with the shortest distance from $s$ to $v$, respectively from $t$ to $v$. Connecting the labels which correspond to the shortest subpaths $s$-$v$ and $t$-$v$ does not necessarily comply with the driving time constraints $R$. We therefore have to proof that in the case in which the shortest $s$-$t$ path is not the combination of the two shortest subpaths, the correct solution is found nevertheless before the search stops. TODO
\end{proof}

\subsection{Bidirectional A*}
We now extend the bidirectional search to a bidirectional A* search. Thus, we use a forward potential $\overrightarrow{\concretepotential}_t(l,v)$ and a backwards potential $\overleftarrow{\concretepotential}_t(l,v)$. Connecting two subpaths of forward and backward search to an $s$-$t$ path remains unchanged since we only use the potentials for the queue keys of $\overrightarrow{Q}$ and $\overleftarrow{Q}$. We use components $\breakDist_1$ and $\breakDist_1$ of the two labels to test if the connected path complies with the driving time constraints $R$ and sum the both $\concretett$ components of the two labels to obtain the travel time $\traveltime(s,t)$ of the full path.

With a bidirectional A* search, we can use the progress and the potential of the backward search to prune the forward search and vice versa. [TODO cite] A label $l$ at a node $v$ which was propagated along an edge $(u,v)$ can be discarded if we can proof that all paths using the label are longer or equal to the tentative travel time $\tenttraveltime(s,t)$. We know the travel time $\concretett(l)$ of the label $l$ at $v$ and need to find a lower bound for the remaining distance to $t$. We will describe the pruning of the forward search, the backward search can be pruned accordingly.

The backwards queue $\overleftarrow{Q}$ contains labels with a key of $\concretett(l) + \concretepotential_s(l,v)$ for label $l \in \overleftarrow{L}(v)$. Labels are removed from the queue with an increasing key. Therefore, we know that if a label  TODO continue

\section{Core Contraction Hierarchy with Two Driving Time Constraints}
Given a Graph $G = (V,E,\mathfunction{len})$, we construct a core contraction hierarchy in which the core contains all the parking nodes $P \subseteq V$. We denote the set of uncontracted core nodes as $C \subseteq V$. It is $P \subseteq C$. The set of nodes $V$ therefore is split into a set of core nodes $C$ and a set of contracted nodes $V_{CH} = V \setminus C$. The Graph $G_{CH} = (V_{CH},E_{CH},\mathfunction{len})$ with nodes $V_{CH}$ and edges $E_{CH} = \{(u,v) \in E : u,v \in V_{CH}\}$ therefore is a valid contraction hierarchy. It contains only contracted nodes and edges between those nodes. Thus, $E_{CH}$ contains only upward edges. The Graph $G_{C} = (V \setminus V_{CH},E \setminus E_{CH},\mathfunction{len})$ is called the core graph.

The core CH query essentially is a bidirectional Dijkstra with a modified stopping criterion. It operates on a modified forward graph $\overrightarrow{G}^*$ and a modified backward graph $\overleftarrow{G}^*$. The forward graph $\overrightarrow{G}^* = (V,\overrightarrow{E}^*,\mathfunction{len})$ consists of the forward graph of the contraction hierarchy $\overrightarrow{G}_{CH}$, extended by the core graph $G_C$. It is $\overrightarrow{E}^* = \overrightarrow{E}_{CH} \cup E_C $. Equivalently, the backward graph is defined as $\overleftarrow{G}^* = (V,\overleftarrow{E}^*,\overleftarrow{\mathfunction{len}})$ with $\overleftarrow{E}^* = \overleftarrow{E}_{CH} \cup E_C$ and $\overleftarrow{\mathfunction{len}}(u,v) = \mathfunction{len}(v,u)$.

The bidirectional query in $G^*$ consists of a forward search from $s$ in $\overrightarrow{G}^*$ and backward search from $t$ in $\overleftarrow{G}^*$. Each search consists of two parts, an upward search in $G_{CH}$ and a Dijkstra search in $G_C$. A search may begin at a core node and only perform the Dijkstra search. It also may not reach the core graph at all and only perform the CH upward search.

The stopping criterion of the bidirectional search must take into account that the Graph $G^*$ contains the contraction hierarchy $G_{CH}$. The common stopping criterion for $s$-$t$ queries in a CH is to stop the search if the minimum queue key of both queues $\overrightarrow{Q}$ and $\overleftarrow{Q}$ is greater or equal to the tentative minimum distance $\distance(s,t)$ \cite{geisberger:2012}. Since this criterion is more conservative than the stopping criterion for a bidirectional Dijkstra search, we can use it for our combination of CH and bidirectional Dijkstra.

\begin{algorithm}[hbtp]
	\caption{\textsc{Core-CH with Driving Time Constraints}}\label{alg:CSPCoreCH}

	% Some settings
	\DontPrintSemicolon %dontprintsemicolon
	\SetFuncSty{textsc}
	\SetKwFor{ForAll}{forall}{do}

	% Declaration of data containers and functions
	\SetKwData{Q}{Q}
	\SetKwData{L}{L}
	\SetKwData{pot}{pot}
	\SetKwFunction{queueDeleteMin}{deleteMin}
	\SetKwFunction{queueInsert}{insert}
	\SetKwFunction{queueMin}{min}
	\SetKwFunction{queueMinKey}{minKey}
	\SetKwFunction{queueDecreaseKey}{decreaseKey}
	\SetKwFunction{queueContains}{contains}
	\SetKwFunction{listInsert}{insert}
	\SetKwFunction{removeDom}{removeDominated}

	% Algorithm interface
	\KwIn{Graph $G = (V,E,\mathfunction{len})$, parking nodes $P \subseteq V$, driving time constraint $r$, potential \pot{}, source node $s \in V$}
	\KwData{Priority queue \Q, per node priority queue \L{$v$} of labels for all $v \in V$}
	\KwOut{Distances for all $v \in V$, tree of allowed shortest paths according to the restriction $r$ from $s$, given by $l_{pred}$}

	% The algorithm
	\BlankLine
	\tcp{Initialization}
	\Q.\queueInsert{$s,(0,0)$}\;
	\L{$s$}.\queueInsert{$(\bot,\bot),\pot{(0,0)}$}\;
	$fwNext \leftarrow true$\;
	\BlankLine
	\tcp{Main loop}
	\While{stopping criterion is not met}
	{
		\If{$fwNext$}{}
		$u \leftarrow$ \Q.\queueDeleteMin{} \;
		$(\concretett, \breakDist_1) \leftarrow$ \L{$u$}.\queueMinKey{} \;
		$l \leftarrow$ \L{$u$}.\queueDeleteMin{} \;
		\BlankLine
		\If{\L{$u$} is not empty}
		{
			$k_{dist} \leftarrow$ \L{$u$}.\queueMinKey{} \;
			\Q.\queueInsert{$u$, $k_{dist}$} \;
		}

		\ForAll{ $(u,v) \in E$ }
		{
			\If{$\concretett + \mathfunction{len}(u,v) < \restr_d$}
			{
				$D \leftarrow \{(\concretett + \mathfunction{len}(u,v), \breakDist_1 + \mathfunction{len}(u,v))\}$

				\If{$v \in P$}
				{
					$D$.\listInsert{$(\concretett + \mathfunction{len}(u,v) + \restr_p, 0)$}
				}

				\ForAll{ $x \in D$ }
				{
					\If{$x$ is not dominated by any label in \L{$v$}}
					{
						\L{$v$}.\removeDom{$x$} \;
						\L{$v$}.\queueInsert{$(l,(u,v)), x$} \;
						\uIf{\Q.\queueContains{v}}
						{
							\Q.\queueDecreaseKey{$v, x$}
						}
						\Else
						{
							\Q.\queueInsert{$v, x$}
						}
					}
				}
			}
		}
	}
\end{algorithm}

To proof the correctness of the search, we will differentiate between the cases where neither of the two searches reaches the core and where at least one of the searches does reach the core. TODO

\subsection{Building the Contraction Hierarchy}

\section{Combining A* and Core Contraction Hierarchy}